<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
    <title>CH3SS</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
    <script src="https://unpkg.com/@farcade/game-sdk@latest/dist/index.min.js"></script>
    <style>
      /* Global Styles */
      *,
      *::before,
      *::after {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      html {
        -webkit-text-size-adjust: none;
        text-size-adjust: none;
      }

      body {
        width: 100%;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        background: linear-gradient(135deg, #120025 0%, #050520 100%);
        font-family: "Press Start 2P", monospace;
        color: #00ffff;
        overflow: hidden;
        padding: 0px;
      }

      /* Arcade Cabinet Styling - Mobile First Approach */
      .arcade {
        max-width: 400px;
        max-height: 800px;
        width: 100%;
        height: auto;
        padding: 5px;
        border-radius: 10px;
        box-shadow:
          0 0 20px #ff00ff,
          0 0 30px rgba(0, 255, 255, 0.5) inset;
        background: rgba(0, 0, 0, 0.8);
        border: 2px solid #ff00ff;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        /* Logical canvas size for game elements */
        --canvas-width: 500px;
        --canvas-height: 800px;
        aspect-ratio: 500 / 800;
      }

      .title {
        text-align: center;
        font-size: 1.5rem;
        margin-bottom: 15px;
        font-weight: bold;
        text-shadow:
          0 0 10px #00ffff,
          0 0 20px #ff00ff;
        letter-spacing: 0.1em;
      }

      /* Game Area */
      .game-area {
        display: flex;
        flex-direction: column;
        gap: 15px;
        justify-content: center;
        align-items: center;
        width: 100%;
      }

      /* Board Styling - Responsive */
      .board {
        display: flex;
        flex-direction: column;
        border: 2px solid #00ffff;
        box-shadow:
          0 0 15px #00ffff,
          0 0 5px rgba(0, 255, 255, 0.5) inset;
        position: relative;
        width: 100%;
        max-width: 360px; /* Maximized size for 400px container width */
        margin: 0 auto;
        touch-action: none;
      }

      .row {
        display: flex;
        width: 100%;
      }

      .square {
        width: 12.5%; /* 100% ÷ 8 squares */
        position: relative;
        padding-bottom: 12.5%; /* Makes squares perfect */
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .piece {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80%; /* Percentage of square size */
        height: 80%; /* Maintain aspect ratio */
        display: flex;
        justify-content: center;
        align-items: center;
        user-select: none;
        -webkit-user-select: none;
        -ms-user-select: none;
        /* Use viewport-relative font sizing with a minimum */
        font-size: clamp(16px, 4.5vmin, 32px);
        line-height: 1;
        cursor: grab;
      }

      .light-square {
        background: #00ffff10;
        box-shadow: 0 0 5px #00ffff inset;
      }

      .dark-square {
        background: #00000080;
      }

      .selected {
        background: #ff00ff80 !important;
        box-shadow:
          0 0 15px #ff00ff,
          0 0 5px #ff00ff inset !important;
      }

      .last-move-from {
        background: rgba(255, 255, 255, 0.3) !important;
        box-shadow:
          0 0 10px rgba(255, 255, 255, 0.5),
          0 0 5px rgba(255, 255, 255, 0.5) inset !important;
      }

      .last-move-to {
        background: rgba(255, 255, 255, 0.4) !important;
        box-shadow:
          0 0 10px rgba(255, 255, 255, 0.6),
          0 0 5px rgba(255, 255, 255, 0.6) inset !important;
      }

      .valid-move {
        background: #00ff0040 !important;
        box-shadow:
          0 0 15px #00ff00,
          0 0 5px #00ff00 inset !important;
      }

      .white-piece {
        color: #ffffff;
        text-shadow:
          0 0 5px #00ffff,
          0 0 10px #00ffff;
      }

      .black-piece {
        color: #ff50f0;
        text-shadow:
          0 0 5px #ff00ff,
          0 0 10px #ff00ff;
      }

      /* Game Info Panel */
      .info-container {
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 5px;
        width: 100%;
        max-width: 360px;
      }

      .display {
        border: 2px solid #00ffff;
        border-radius: 5px;
        box-shadow:
          0 0 10px #00ffff,
          0 0 5px rgba(0, 255, 255, 0.3) inset;
        overflow: hidden;
      }

      .display-header {
        font-size: 0.45rem;
        background: #00ffff20;
        padding: 3px 6px;
        border-bottom: 1px solid #00ffff;
        text-align: center;
      }

      .display-content {
        font-size: 0.65rem;
        padding: 5px;
        text-align: center;
        text-shadow: 0 0 5px #00ffff;
        letter-spacing: 0.1em;
        min-height: 22px;
      }

      .info-row {
        display: flex;
        gap: 8px;
        width: 100%;
        margin-bottom: 8px;
      }

      .info-panel {
        flex: 1;
      }

      .rules-content {
        font-size: 0.45rem;
        line-height: 1.5;
        color: #ff99ff;
        text-shadow: 0 0 3px #ff00ff;
        text-align: left;
        padding: 6px;
      }

      .menu-content {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 6px;
      }

      .menu-inline-button {
        background: transparent;
        color: #ff00ff;
        border: 1px solid #ff00ff;
        padding: 4px 8px;
        font-size: 0.5rem;
        border-radius: 3px;
        cursor: pointer;
        box-shadow: 0 0 3px #ff00ff;
        font-family: "Press Start 2P", monospace;
        transition: all 0.3s ease;
        text-shadow: 0 0 3px #ff00ff;
      }

      .menu-inline-button:hover {
        background: #ff00ff20;
        box-shadow: 0 0 6px #ff00ff;
      }

      /* Captured Pieces Display */
      .captured-container {
        display: flex;
        flex-direction: column;
        gap: 8px;
        width: 100%;
      }

      .captured-display {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        position: relative;
      }

      .captured-pieces {
        font-size: 0.6rem;
        display: flex;
        flex-wrap: wrap;
        gap: 3px;
        padding: 2px;
        min-height: 22px;
        flex: 1;
      }

      .score-display {
        font-size: 0.6rem;
        margin-left: 5px;
        margin-right: 5px;
      }

      .score-white {
        color: #ffffff;
        text-shadow: 0 0 5px #00ffff;
      }

      .score-black {
        color: #ff50f0;
        text-shadow: 0 0 5px #ff00ff;
      }

      .scoreboard {
        border: 2px solid #ff00ff;
        border-radius: 5px;
        box-shadow:
          0 0 10px #ff00ff,
          0 0 5px rgba(255, 0, 255, 0.3) inset;
        margin-top: 5px;
        overflow: hidden;
      }

      .scoreboard-text {
        font-size: 0.75rem;
        padding: 20px 50px 20px 50px;
        line-height: 2;
        color: #ff99ff;
        text-shadow: 0 0 3px #ff00ff;
        text-align: center;
      }

      .winner {
        color: #ff00ff;
        margin-top: 5px;
        font-size: 0.6rem;
        font-weight: bold;
        text-shadow:
          0 0 8px #ff00ff,
          0 0 4px #ffffff;
        animation: pulse 1.5s infinite alternate;
      }

      /* Game Controls */
      .controls {
        margin-top: 10px;
        display: flex;
        justify-content: center;
        width: 100%;
      }

      .button {
        background: transparent;
        color: #ff00ff;
        border: 2px solid #ff00ff;
        padding: 8px 15px;
        font-size: 0.7rem;
        border-radius: 5px;
        cursor: pointer;
        box-shadow: 0 0 5px #ff00ff;
        font-family: "Press Start 2P", monospace;
        transition: all 0.3s ease;
        text-shadow: 0 0 5px #ff00ff;
      }

      .button:hover,
      .button:active {
        background: #ff00ff20;
        box-shadow:
          0 0 10px #ff00ff,
          0 0 5px #ff00ff inset;
      }

      /* Modal Styles */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 100;
        animation: fadeIn 0.3s ease-in-out;
      }

      .modal-overlay.active {
        display: flex;
      }

      .modal {
        background: #120318;
        border: 2px solid #00ffff;
        box-shadow:
          0 0 20px #00ffff,
          0 0 10px rgba(0, 255, 255, 0.5) inset;
        border-radius: 5px;
        width: 90%;
        max-width: 350px;
        max-height: 90vh;
        overflow-y: auto;
        animation: scaleIn 0.3s ease-out;
        padding: 15px;
        color: #ffffff;
      }

      .modal-header {
        font-size: 0.9rem;
        color: #00ffff;
        text-shadow: 0 0 5px #00ffff;
        text-align: center;
        margin-bottom: 15px;
        border-bottom: 1px solid #00ffff50;
        padding-bottom: 10px;
      }

      .modal-section {
        margin-bottom: 15px;
        border-bottom: 1px solid #ff00ff30;
        padding-bottom: 10px;
      }

      .modal-section-title {
        font-size: 0.6rem;
        color: #ff00ff;
        text-shadow: 0 0 3px #ff00ff;
        margin-bottom: 8px;
      }

      .modal-content {
        font-size: 0.5rem;
        line-height: 1.4;
        color: #dddddd;
      }

      .modal-buttons {
        display: flex;
        justify-content: space-between;
        margin-top: 15px;
      }

      .modal-button {
        background: transparent;
        border: 1px solid #00ffff;
        color: #00ffff;
        padding: 5px 10px;
        font-size: 0.5rem;
        border-radius: 3px;
        cursor: pointer;
        font-family: "Press Start 2P", monospace;
        transition: all 0.2s;
        text-shadow: 0 0 3px #00ffff;
      }

      .modal-button:hover {
        background: #00ffff20;
        box-shadow: 0 0 8px #00ffff;
      }

      .modal-button.danger {
        border-color: #ff00ff;
        color: #ff00ff;
        text-shadow: 0 0 3px #ff00ff;
      }

      .modal-button.danger:hover {
        background: #ff00ff20;
        box-shadow: 0 0 8px #ff00ff;
      }

      /* Game mode options */
      .option-group {
        margin: 10px 0;
      }

      .option-label {
        font-size: 0.45rem;
        color: #00ffff;
        margin-bottom: 5px;
      }

      .option-buttons {
        display: flex;
        flex-direction: column;
        gap: 5px;
      }

      .option-button {
        background: transparent;
        border: 1px solid #666;
        color: #aaa;
        padding: 4px 8px;
        font-size: 0.45rem;
        cursor: pointer;
        font-family: "Press Start 2P", monospace;
        transition: all 0.2s;
        text-align: center;
      }

      .option-button.active {
        border-color: #00ffff;
        color: #00ffff;
        box-shadow: 0 0 5px #00ffff;
      }

      .spacer-small {
        height: 10px;
      }

      @keyframes scaleIn {
        from {
          transform: scale(0.8);
          opacity: 0;
        }
        to {
          transform: scale(1);
          opacity: 1;
        }
      }

      /* Checkmate Overlay */
      .checkmate-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.6);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10;
        animation: fadeIn 0.5s ease-in-out;
      }

      .checkmate-text {
        color: #ff00ff;
        font-size: 1.2rem;
        font-weight: bold;
        text-shadow:
          0 0 10px #ff00ff,
          0 0 20px #ff00ff,
          0 0 30px #ff00ff;
        padding: 15px;
        border: 2px solid #ff00ff;
        border-radius: 5px;
        background: rgba(0, 0, 0, 0.8);
        box-shadow:
          0 0 20px #ff00ff,
          0 0 10px rgba(255, 0, 255, 0.5) inset;
      }

      /* Animations */
      @keyframes pulse {
        from {
          opacity: 0.7;
          text-shadow: 0 0 5px #ff00ff;
        }
        to {
          opacity: 1;
          text-shadow:
            0 0 15px #ff00ff,
            0 0 25px #ffffff;
        }
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      /* Media Queries for Responsive Design - Tablet & Desktop */
      @media (max-width: 480px) {
        .piece {
          /* Adjust for smaller screens */
          width: 75%;
          height: 75%;
          font-size: clamp(14px, 8vmin, 28px);
        }
      }

      @media screen and (-webkit-min-device-pixel-ratio: 2) {
        .piece {
          /* Adjust for high DPI screens */
          font-size: clamp(14px, 9vmin, 32px);
        }
      }

      @media screen and (-webkit-min-device-pixel-ratio: 3) {
        .piece {
          /* Adjust for even higher DPI screens (iPhone) */
          font-size: clamp(14px, 10vmin, 42px);
          top: 40%;
        }
      }

      @media (min-width: 481px) {
        .arcade {
          padding: 8px;
        }

        .title {
          font-size: 1.8rem;
          margin-bottom: 20px;
          letter-spacing: 0.2em;
        }

        .piece {
          font-size: 24px;
        }

        .display-header {
          font-size: 0.6rem;
        }

        .display-content {
          font-size: 0.8rem;
        }

        .scoreboard-text {
          font-size: 0.5rem;
          padding: 10px;
        }

        .button {
          padding: 10px 20px;
          font-size: 0.8rem;
        }
      }

      @media (min-width: 768px) {
        .game-area {
          flex-direction: row;
          justify-content: center;
          align-items: flex-start;
        }

        .info-container {
          width: 180px;
        }

        .arcade {
          display: block;
        }
      }

      /* Touch drag and drop styles */
      .ghost-piece {
        position: fixed;
        pointer-events: none;
        z-index: 1000;
        opacity: 0.8;
        transform: translate(-50%, -65%) scale(3.1);
        transition: transform 0.1s ease;
      }

      .piece.dragging {
        opacity: 0.3;
      }

      .square.valid-drop {
        background: rgba(0, 255, 0, 0.2) !important;
        box-shadow: 0 0 15px 10px #00ff00 !important;
      }

      .square.capture-highlight {
        background: rgba(255, 0, 0, 0.3) !important;
        box-shadow: 0 0 15px 10px #ff0000 !important;
        animation: captureFlash 0.3s ease;
      }

      @keyframes captureFlash {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
        100% {
          transform: scale(1);
        }
      }
    </style>
  </head>
  <body>
    <div class="arcade">
      <div class="title">CH3SS</div>
      <div class="game-area">
        <div id="board" class="board"></div>
        <div class="info-container">
          <!-- Row 1: Player - Status -->
          <div class="info-row">
            <div class="info-panel">
              <div class="display">
                <div class="display-header">PLAYER</div>
                <div id="current-player" class="display-content">WHITE</div>
              </div>
            </div>
            <div class="info-panel">
              <div class="display">
                <div class="display-header">STATUS</div>
                <div id="game-status" class="display-content">PLAYING vs AI</div>
              </div>
            </div>
          </div>

          <!-- Row 2: White Captured - Black Captured -->
          <div class="info-row">
            <div class="info-panel">
              <div class="display">
                <div class="display-header">WHITE CAPTURED</div>
                <div class="display-content captured-display">
                  <div id="white-captured" class="captured-pieces white-piece"></div>
                  <div id="white-score" class="score-display score-white">+0</div>
                </div>
              </div>
            </div>
            <div class="info-panel">
              <div class="display">
                <div class="display-header">BLACK CAPTURED</div>
                <div class="display-content captured-display">
                  <div id="black-captured" class="captured-pieces black-piece"></div>
                  <div id="black-score" class="score-display score-black">+0</div>
                </div>
              </div>
            </div>
          </div>

          <!-- Row 3: CyberChess - Menu -->
          <div class="info-row">
            <div class="info-panel">
              <div class="display">
                <div class="display-header">CH3SS</div>
                <div class="display-content rules-content">
                  <div
                    id="pgn-output"
                    style="font-size: 0.45rem; color: #00ffff; text-align: center; margin-top: 0px"
                  ></div>
                </div>
              </div>
            </div>
            <div class="info-panel">
              <div class="display">
                <div class="display-header">MENU</div>
                <div class="display-content menu-content">
                  <button id="menu-button" class="menu-inline-button">OPTIONS</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Game Menu Modal -->
    <div id="menu-modal" class="modal-overlay">
      <div class="modal">
        <div class="modal-header">CH3SS MENU</div>

        <div class="modal-section">
          <div class="modal-section-title">GAME MODE:</div>
          <div class="modal-content">
            <div class="option-group">
              <div class="option-buttons">
                <button id="mode-human" class="option-button">VS HUMAN</button>
                <button id="mode-ai" class="option-button active">VS AI</button>
                <button id="mode-puzzle" class="option-button">PUZZLES</button>
              </div>
            </div>

            <div id="ai-options" class="option-group">
              <div class="option-label">PLAY AS:</div>
              <div class="option-buttons">
                <button id="ai-color-white" class="option-button active">WHITE (YOU PLAY FIRST)</button>
                <button id="ai-color-black" class="option-button">BLACK (AI PLAYS FIRST)</button>
              </div>
            </div>

            <div id="puzzle-options" class="option-group" style="display: none">
              <div class="option-label">PUZZLE TYPE:</div>
              <div class="option-buttons">
                <button id="puzzle-tutorial" class="option-button active">TUTORIAL</button>
                <button id="puzzle-core" class="option-button">CORE</button>
                <button id="puzzle-spice" class="option-button">SPICE</button>
                <button id="puzzle-boss" class="option-button">BOSS</button>
              </div>
            </div>

            <div class="spacer-small"></div>
            <button id="new-game-modal" class="modal-button">NEW GAME</button>
          </div>
        </div>

        <div class="modal-section">
          <div class="modal-section-title">GAME RULES</div>
          <div class="modal-content">
            Standard chess rules apply in a cyberpunk setting:<br /><br />
            • Each piece has a unique movement pattern<br />
            • Pawns move forward one square, capture diagonally<br />
            • Knights move in an L-shape, can jump over pieces<br />
            • Bishops move diagonally any number of squares<br />
            • Rooks move horizontally or vertically<br />
            • Queens combine bishop and rook moves<br />
            • Kings move one square in any direction<br />
            • Checkmate happens when the king is threatened with capture and can't escape
          </div>
        </div>

        <div class="modal-section">
          <div class="modal-section-title">SPECIAL MOVES</div>
          <div class="modal-content">
            • Castling: King moves two squares toward a rook, and the rook moves to the other side of the king<br />
            • En Passant: Pawns can capture an opponent's pawn that has moved two squares forward in one move<br />
            • Pawn Promotion: When a pawn reaches the opposite end of the board, it can be promoted to any other piece
          </div>
        </div>

        <div class="modal-section">
          <div class="modal-section-title">PIECE VALUES</div>
          <div class="modal-content">
            • Pawn: 1 point<br />
            • Knight: 3 points<br />
            • Bishop: 3 points<br />
            • Rook: 5 points<br />
            • Queen: 9 points<br />
            • King: Infinite (game lost if checkmate)
          </div>
        </div>

        <div class="modal-buttons">
          <button id="close-modal" class="modal-button">CLOSE</button>
        </div>
      </div>
    </div>

    <script>
      // Chess Game Logic

      // Initial board state (8x8 grid)
      // Uppercase = White pieces, Lowercase = Black pieces
      // R=Rook, N=Knight, B=Bishop, Q=Queen, K=King, P=Pawn
      const initialBoardState = [
        ["r", "n", "b", "q", "k", "b", "n", "r"],
        ["p", "p", "p", "p", "p", "p", "p", "p"],
        [null, null, null, null, null, null, null, null],
        [null, null, null, null, null, null, null, null],
        [null, null, null, null, null, null, null, null],
        [null, null, null, null, null, null, null, null],
        ["P", "P", "P", "P", "P", "P", "P", "P"],
        ["R", "N", "B", "Q", "K", "B", "N", "R"],
      ];

      // Unicode mapping for chess pieces
      const pieceMapping = {
        k: "♚",
        q: "♛",
        r: "♖",
        b: "♗",
        n: "♘",
        p: "♙",
        K: "♚",
        Q: "♛",
        R: "♖",
        B: "♗",
        N: "♘",
        P: "♙",
      };

      // Game state variables
      let moveHistory = []; // PGN-style move tracker
      let boardState = JSON.parse(JSON.stringify(initialBoardState));
      let selectedPiece = null;
      let currentPlayer = "white";
      let gameStatus = "playing"; // playing, check, checkmate, draw
      let drawReason = null; // null, "stalemate", "50move", "repetition"
      let validMoves = [];
      let enPassantTarget = null;
      let touchStartSquare = null;

      // AI variables
      let gameMode = "ai"; // human, ai
      let aiColor = "black"; // AI will play as black by default
      let aiThinking = false; // Flag to prevent interactions while AI is thinking

      // Farcade SDK variables
      let isMuted = false; // Track if sound is muted
      let gameScore = 0; // Track player's score

      // Track last move for highlighting
      let lastMove = {
        from: null, // [row, col]
        to: null, // [row, col]
      };

      // Track 50-move rule only counts moves since the last pawn move or capture
      let halfMoveClock = 0;

      let positionCounts = {}; // For threefold repetition

      // Track captured pieces
      let capturedPieces = {
        white: [], // Pieces captured by white player
        black: [], // Pieces captured by black player
      };

      // Track castling rights
      let castlingRights = {
        whiteKingSide: true,
        whiteQueenSide: true,
        blackKingSide: true,
        blackQueenSide: true,
      };

      // DOM Elements
      const boardElement = document.getElementById("board");
      const currentPlayerElement = document.getElementById("current-player");
      const gameStatusElement = document.getElementById("game-status");
      const menuButton = document.getElementById("menu-button");
      const menuModal = document.getElementById("menu-modal");
      const newGameModalButton = document.getElementById("new-game-modal");
      const closeModalButton = document.getElementById("close-modal");
      const whiteCapturedElement = document.getElementById("white-captured");
      const blackCapturedElement = document.getElementById("black-captured");
      const whiteScoreElement = document.getElementById("white-score");
      const blackScoreElement = document.getElementById("black-score");

      // Helper Functions

      // Returns the color of a piece ('white', 'black', or null if empty)
      function getPieceColor(piece) {
        if (!piece) return null;
        return piece === piece.toUpperCase() ? "white" : "black";
      }

      // Check if a move is within the board boundaries
      function isInBounds(row, col) {
        return row >= 0 && row < 8 && col >= 0 && col < 8;
      }

      // Check for Repetition Draw
      function getBoardKey(boardState, currentPlayer) {
        return JSON.stringify(boardState) + "_" + currentPlayer;
      }

      // Get all valid moves for a pawn
      function getPawnMoves(row, col, piece, boardState, enPassantTarget) {
        const moves = [];
        const direction = getPieceColor(piece) === "white" ? -1 : 1;
        const startRow = getPieceColor(piece) === "white" ? 6 : 1;

        // Move forward one square
        if (isInBounds(row + direction, col) && boardState[row + direction][col] === null) {
          moves.push([row + direction, col]);

          // Move forward two squares from starting position
          if (
            row === startRow &&
            isInBounds(row + 2 * direction, col) &&
            boardState[row + 2 * direction][col] === null
          ) {
            moves.push([row + 2 * direction, col]);
          }
        }

        // Capture diagonally
        const captureDirections = [
          [direction, -1],
          [direction, 1],
        ];
        for (const [dr, dc] of captureDirections) {
          const newRow = row + dr;
          const newCol = col + dc;

          if (isInBounds(newRow, newCol)) {
            const targetPiece = boardState[newRow][newCol];
            if (targetPiece && getPieceColor(targetPiece) !== getPieceColor(piece)) {
              moves.push([newRow, newCol]);
            }

            // En passant capture
            if (enPassantTarget && newRow === enPassantTarget[0] && newCol === enPassantTarget[1]) {
              moves.push([newRow, newCol]);
            }
          }
        }

        return moves;
      }

      // Get all valid moves for a knight
      function getKnightMoves(row, col, piece, boardState) {
        const moves = [];
        const directions = [
          [-2, -1],
          [-2, 1],
          [-1, -2],
          [-1, 2],
          [1, -2],
          [1, 2],
          [2, -1],
          [2, 1],
        ];

        for (const [dr, dc] of directions) {
          const newRow = row + dr;
          const newCol = col + dc;

          if (isInBounds(newRow, newCol)) {
            const targetPiece = boardState[newRow][newCol];
            if (!targetPiece || getPieceColor(targetPiece) !== getPieceColor(piece)) {
              moves.push([newRow, newCol]);
            }
          }
        }

        return moves;
      }

      // Get all valid moves for a bishop
      function getBishopMoves(row, col, piece, boardState) {
        const moves = [];
        const directions = [
          [-1, -1],
          [-1, 1],
          [1, -1],
          [1, 1],
        ];

        for (const [dr, dc] of directions) {
          let newRow = row + dr;
          let newCol = col + dc;

          while (isInBounds(newRow, newCol)) {
            const targetPiece = boardState[newRow][newCol];

            if (!targetPiece) {
              moves.push([newRow, newCol]);
            } else {
              if (getPieceColor(targetPiece) !== getPieceColor(piece)) {
                moves.push([newRow, newCol]);
              }
              break; // Stop after capture
            }

            newRow += dr;
            newCol += dc;
          }
        }

        return moves;
      }

      // Get all valid moves for a rook
      function getRookMoves(row, col, piece, boardState) {
        const moves = [];
        const directions = [
          [-1, 0],
          [1, 0],
          [0, -1],
          [0, 1],
        ];

        for (const [dr, dc] of directions) {
          let newRow = row + dr;
          let newCol = col + dc;

          while (isInBounds(newRow, newCol)) {
            const targetPiece = boardState[newRow][newCol];

            if (!targetPiece) {
              moves.push([newRow, newCol]);
            } else {
              if (getPieceColor(targetPiece) !== getPieceColor(piece)) {
                moves.push([newRow, newCol]);
              }
              break; // Stop after capture
            }

            newRow += dr;
            newCol += dc;
          }
        }

        return moves;
      }

      // Get all valid moves for a queen (combines bishop and rook moves)
      function getQueenMoves(row, col, piece, boardState) {
        return [...getBishopMoves(row, col, piece, boardState), ...getRookMoves(row, col, piece, boardState)];
      }

      // Get all valid moves for a king
      function getKingMoves(row, col, piece, boardState) {
        const moves = [];
        const directions = [
          [-1, -1],
          [-1, 0],
          [-1, 1],
          [0, -1],
          [0, 1],
          [1, -1],
          [1, 0],
          [1, 1],
        ];

        // Regular king moves
        for (const [dr, dc] of directions) {
          const newRow = row + dr;
          const newCol = col + dc;

          if (isInBounds(newRow, newCol)) {
            const targetPiece = boardState[newRow][newCol];
            if (!targetPiece || getPieceColor(targetPiece) !== getPieceColor(piece)) {
              moves.push([newRow, newCol]);
            }
          }
        }

        // Castling moves
        const isWhite = getPieceColor(piece) === "white";

        // Kingside castling
        if ((isWhite && castlingRights.whiteKingSide) || (!isWhite && castlingRights.blackKingSide)) {
          if (boardState[row][col + 1] === null && boardState[row][col + 2] === null) {
            if (
              !isInCheck(currentPlayer, boardState) &&
              !wouldBeInCheck(row, col, row, col + 1, piece, boardState) &&
              !wouldBeInCheck(row, col, row, col + 2, piece, boardState)
            ) {
              moves.push([row, col + 2]);
            }
          }
        }

        // Queenside castling
        if ((isWhite && castlingRights.whiteQueenSide) || (!isWhite && castlingRights.blackQueenSide)) {
          if (
            boardState[row][col - 1] === null &&
            boardState[row][col - 2] === null &&
            boardState[row][col - 3] === null
          ) {
            if (
              !isInCheck(currentPlayer, boardState) &&
              !wouldBeInCheck(row, col, row, col - 1, piece, boardState) &&
              !wouldBeInCheck(row, col, row, col - 2, piece, boardState)
            ) {
              moves.push([row, col - 2]);
            }
          }
        }

        return moves;
      }

      // Get all valid moves for a piece
      function getValidMoves(row, col, piece, boardState, enPassantTarget = null) {
        if (!piece) return [];

        const pieceType = piece.toLowerCase();

        switch (pieceType) {
          case "p":
            return getPawnMoves(row, col, piece, boardState, enPassantTarget);
          case "n":
            return getKnightMoves(row, col, piece, boardState);
          case "b":
            return getBishopMoves(row, col, piece, boardState);
          case "r":
            return getRookMoves(row, col, piece, boardState);
          case "q":
            return getQueenMoves(row, col, piece, boardState);
          case "k":
            return getKingMoves(row, col, piece, boardState);
          default:
            return [];
        }
      }

      // Check if a move would result in check
      function wouldBeInCheck(fromRow, fromCol, toRow, toCol, piece, boardState) {
        // Create a copy of the board with the move applied
        const testBoard = JSON.parse(JSON.stringify(boardState));
        testBoard[toRow][toCol] = piece;
        testBoard[fromRow][fromCol] = null;

        // Check if the king would be in check after this move
        return isInCheck(getPieceColor(piece), testBoard);
      }

      // Find the king's position for a given color
      function findKing(color, boardState) {
        const kingSymbol = color === "white" ? "K" : "k";

        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            if (boardState[row][col] === kingSymbol) {
              return [row, col];
            }
          }
        }

        return null; // King not found (shouldn't happen in a valid game)
      }

      // Debugging function
      function debugLog(message, data = null) {
        const timestamp = new Date().toISOString().split("T")[1].split(".")[0];
        console.log(`[${timestamp}] ${message}`, data ? data : "");
      }

      // Direct check detection without using move validation
      function isSquareAttacked(row, col, byColor, boardState) {
        // --- CORRECTED Pawn Attack Check V2 ---
        // Check if the target square (row, col) is attacked by a pawn of 'byColor'
        let attackingPawnRow;
        let pawnToFind;

        if (byColor === "white") {
          // White pawns ('P') attack diagonally "forward" from their perspective,
          // which means a DECREASING row index from the board's perspective.
          // Therefore, if square (row, col) is attacked by a White Pawn,
          // that pawn must be on the row BELOW it (row + 1).
          attackingPawnRow = row + 1;
          pawnToFind = "P";
        } else {
          // byColor === 'black'
          // Black pawns ('p') attack diagonally "forward" from their perspective,
          // which means an INCREASING row index from the board's perspective.
          // Therefore, if square (row, col) is attacked by a Black Pawn,
          // that pawn must be on the row ABOVE it (row - 1).
          attackingPawnRow = row - 1;
          pawnToFind = "p";
        }

        // Check the two diagonal squares where an attacking pawn of the correct color could be
        const potentialPawnCols = [col - 1, col + 1];

        for (const attackingPawnCol of potentialPawnCols) {
          if (isInBounds(attackingPawnRow, attackingPawnCol)) {
            const piece = boardState[attackingPawnRow][attackingPawnCol];
            if (piece === pawnToFind) {
              // Found a pawn of the correct color in the correct attacking position
              debugLog(
                `Square ${row},${col} is attacked by pawn ${pawnToFind} at ${attackingPawnRow},${attackingPawnCol}`,
              );
              return true; // Square IS attacked by a pawn
            }
          }
        }
        // --- End of CORRECTED Pawn Attack Check V2 ---

        // Check knight attacks
        const knightMoves = [
          [-2, -1],
          [-2, 1],
          [-1, -2],
          [-1, 2],
          [1, -2],
          [1, 2],
          [2, -1],
          [2, 1],
        ];

        for (const [dr, dc] of knightMoves) {
          const r = row + dr;
          const c = col + dc;
          if (isInBounds(r, c)) {
            const piece = boardState[r][c];
            if (piece && piece.toLowerCase() === "n" && getPieceColor(piece) === byColor) {
              debugLog(`Square ${row},${col} is attacked by knight at ${r},${c}`);
              return true;
            }
          }
        }

        // Check diagonal attacks (bishop/queen)
        const bishopDirections = [
          [-1, -1],
          [-1, 1],
          [1, -1],
          [1, 1],
        ];
        for (const [dr, dc] of bishopDirections) {
          let r = row + dr;
          let c = col + dc;
          while (isInBounds(r, c)) {
            const piece = boardState[r][c];
            if (piece) {
              if (getPieceColor(piece) === byColor && (piece.toLowerCase() === "b" || piece.toLowerCase() === "q")) {
                debugLog(`Square ${row},${col} is attacked by bishop/queen at ${r},${c}`);
                return true;
              }
              break; // Stop at first piece encountered in this direction
            }
            r += dr;
            c += dc;
          }
        }

        // Check horizontal/vertical attacks (rook/queen)
        const rookDirections = [
          [-1, 0],
          [1, 0],
          [0, -1],
          [0, 1],
        ];
        for (const [dr, dc] of rookDirections) {
          let r = row + dr;
          let c = col + dc;
          while (isInBounds(r, c)) {
            const piece = boardState[r][c];
            if (piece) {
              if (getPieceColor(piece) === byColor && (piece.toLowerCase() === "r" || piece.toLowerCase() === "q")) {
                debugLog(`Square ${row},${col} is attacked by rook/queen at ${r},${c}`);
                return true;
              }
              break; // Stop at first piece encountered in this direction
            }
            r += dr;
            c += dc;
          }
        }

        // Check king attacks (for adjacent squares)
        const kingMoves = [
          [-1, -1],
          [-1, 0],
          [-1, 1],
          [0, -1],
          [0, 1],
          [1, -1],
          [1, 0],
          [1, 1],
        ];

        for (const [dr, dc] of kingMoves) {
          const r = row + dr;
          const c = col + dc;
          if (isInBounds(r, c)) {
            const piece = boardState[r][c];
            if (piece && piece.toLowerCase() === "k" && getPieceColor(piece) === byColor) {
              debugLog(`Square ${row},${col} is attacked by king at ${r},${c}`);
              return true;
            }
          }
        }

        // If no attacks found
        return false;
      }

      function isInCheck(playerColor, boardState) {
        debugLog(`Checking if ${playerColor} is in check`);
        const kingPosition = findKing(playerColor, boardState);
        if (!kingPosition) {
          debugLog("No king found!");
          return false;
        }

        const [kingRow, kingCol] = kingPosition;
        debugLog(`King found at row: ${kingRow}, col: ${kingCol}`);

        const opponentColor = playerColor === "white" ? "black" : "white";
        const isAttacked = isSquareAttacked(kingRow, kingCol, opponentColor, boardState);

        debugLog(`King at ${kingRow},${kingCol} is${isAttacked ? "" : " not"} in check`);
        return isAttacked;
      }

      // Check if a player is in checkmate
      function isCheckmate(playerColor, boardState) {
        // First, check if the player is in check
        if (!isInCheck(playerColor, boardState)) {
          return false;
        }

        // Try all possible moves for all of the player's pieces
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            const piece = boardState[row][col];

            if (piece && getPieceColor(piece) === playerColor) {
              const moves = getValidMoves(row, col, piece, boardState, enPassantTarget);

              // For each move, check if it gets the player out of check
              for (const [toRow, toCol] of moves) {
                if (!wouldBeInCheck(row, col, toRow, toCol, piece, boardState)) {
                  return false; // Found a legal move that gets out of check
                }
              }
            }
          }
        }

        // No legal moves found, it's checkmate
        return true;
      }

      // Render the chessboard on the screen
      function renderBoard() {
        boardElement.innerHTML = "";

        for (let row = 0; row < 8; row++) {
          const rowElement = document.createElement("div");
          rowElement.className = "row";

          for (let col = 0; col < 8; col++) {
            const squareElement = document.createElement("div");
            const isLightSquare = (row + col) % 2 === 0;

            squareElement.className = `square ${isLightSquare ? "light-square" : "dark-square"}`;
            squareElement.dataset.row = row;
            squareElement.dataset.col = col;

            const piece = boardState[row][col];
            if (piece) {
              const pieceElement = document.createElement("div");
              const pieceColor = getPieceColor(piece);

              pieceElement.className = `piece ${pieceColor}-piece`;
              pieceElement.textContent = pieceMapping[piece];
              squareElement.appendChild(pieceElement);
            }

            // Visual highlights
            if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
              squareElement.classList.add("selected");
            }

            if (validMoves.some(([r, c]) => r === row && c === col)) {
              squareElement.classList.add("valid-move");
            }

            if (lastMove.from && row === lastMove.from[0] && col === lastMove.from[1]) {
              squareElement.classList.add("last-move-from");
            }

            if (lastMove.to && row === lastMove.to[0] && col === lastMove.to[1]) {
              squareElement.classList.add("last-move-to");
            }

            squareElement.addEventListener("click", () => handleSquareClick(row, col));
            rowElement.appendChild(squareElement);
          }

          boardElement.appendChild(rowElement);
        }

        updateGameStatus();
        updateCapturedPieces();
      }

      // Function to evaluate safety of a move by checking attacks and defenders
      function evaluateSquareSafety(toRow, toCol, piece, boardState) {
        const pieceColor = getPieceColor(piece);
        const opponentColor = pieceColor === "white" ? "black" : "white";
        
        // Large penalty for moving to a square attacked by a lower value piece
        const pieceValue = pieceValues[piece.toLowerCase()];
        let safetyScore = 0;
        
        // If square is attacked by opponent
        if (isSquareAttacked(toRow, toCol, opponentColor, boardState)) {
          // Get all opponent pieces that attack this square
          for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
              const attackingPiece = boardState[row][col];
              if (attackingPiece && getPieceColor(attackingPiece) === opponentColor) {
                const moves = getValidMoves(row, col, attackingPiece, boardState);
                if (moves.some(([r, c]) => r === toRow && c === toCol)) {
                  const attackerValue = pieceValues[attackingPiece.toLowerCase()];
                  if (attackerValue < pieceValue) {
                    // Bigger penalty for being attacked by cheaper piece
                    safetyScore -= (pieceValue - attackerValue) * 2;
                  } else {
                    // Smaller penalty for being attacked by more expensive piece
                    safetyScore -= 1;
                  }
                }
              }
            }
          }
        }
        
        return safetyScore;
      }

      // Evaluate the current board state
      function evaluateBoard(boardState) {
        // Material score - main component of evaluation
        const materialScore = calculateMaterialScore(boardState);

        // Position score - small bonus for positional advantages
        const positionScore = calculatePositionScore(boardState);

        // Piece safety score - penalize pieces under attack
        let safetyScore = 0;
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            const piece = boardState[row][col];
            if (piece) {
              safetyScore += evaluateSquareSafety(row, col, piece, boardState);
            }
          }
        }

        // Check and checkmate detection
        let checkScore = 0;

        // Check if white is in check or checkmate
        if (isInCheck("white", boardState)) {
          const whiteMoves = getAllPossibleMoves("white", boardState);
          if (whiteMoves.length === 0) {
            checkScore = -100; // White is checkmated
          } else {
            checkScore = -2; // White is in check
          }
        }

        // Check if black is in check or checkmate
        if (isInCheck("black", boardState)) {
          const blackMoves = getAllPossibleMoves("black", boardState);
          if (blackMoves.length === 0) {
            checkScore = 100; // Black is checkmated
          } else {
            checkScore = 2; // Black is in check
          }
        }

        // Combine scores with appropriate weights
        return materialScore * 10 + positionScore * 3 + safetyScore * 5 + checkScore;
      }

      // Function to move a piece from one square to another
      // This is used by both human player moves and AI moves
      function movePiece(fromRow, fromCol, toRow, toCol) {
        debugLog(`Attempting move from (${fromRow},${fromCol}) to (${toRow},${toCol})`);
        const piece = boardState[fromRow][fromCol];

        if (!piece) {
          debugLog("No piece at source position");
          return false;
        }

        debugLog(`Moving piece: ${piece}`);

        // Create a copy of the board for the new state
        const newBoardState = JSON.parse(JSON.stringify(boardState));

        // Check if a piece is being captured
        const capturedPiece = newBoardState[toRow][toCol];
        if (capturedPiece) {
          // Add to the captured pieces list
          if (currentPlayer === "white") {
            capturedPieces.white.push(capturedPiece);
          } else {
            capturedPieces.black.push(capturedPiece);
          }
        }

        // Reset 50-move rule counter if pawn move or capture, else increment
        if (piece.toLowerCase() === "p" || capturedPiece) {
          halfMoveClock = 0;
        } else {
          halfMoveClock++;
        }

        // Move the piece
        newBoardState[toRow][toCol] = piece;
        newBoardState[fromRow][fromCol] = null;

        // Handle castling
        if (piece.toLowerCase() === "k" && Math.abs(toCol - fromCol) === 2) {
          // Update castling rights
          if (getPieceColor(piece) === "white") {
            castlingRights.whiteKingSide = false;
            castlingRights.whiteQueenSide = false;
          } else {
            castlingRights.blackKingSide = false;
            castlingRights.blackQueenSide = false;
          }

          // Kingside castling
          if (toCol > fromCol) {
            const rookPiece = newBoardState[toRow][7];
            newBoardState[toRow][5] = rookPiece; // Move rook
            newBoardState[toRow][7] = null; // Remove from original position
          }
          // Queenside castling
          else {
            const rookPiece = newBoardState[toRow][0];
            newBoardState[toRow][3] = rookPiece; // Move rook
            newBoardState[toRow][0] = null; // Remove from original position
          }
        }

        // Update castling rights when rooks or kings move
        if (piece.toLowerCase() === "k") {
          if (getPieceColor(piece) === "white") {
            castlingRights.whiteKingSide = false;
            castlingRights.whiteQueenSide = false;
          } else {
            castlingRights.blackKingSide = false;
            castlingRights.blackQueenSide = false;
          }
        } else if (piece.toLowerCase() === "r") {
          if (getPieceColor(piece) === "white") {
            if (fromCol === 0) castlingRights.whiteQueenSide = false;
            if (fromCol === 7) castlingRights.whiteKingSide = false;
          } else {
            if (fromCol === 0) castlingRights.blackQueenSide = false;
            if (fromCol === 7) castlingRights.blackKingSide = false;
          }
        }

        // Handle en passant capture
        if (
          piece.toLowerCase() === "p" &&
          enPassantTarget &&
          toRow === enPassantTarget[0] &&
          toCol === enPassantTarget[1]
        ) {
          // Remove the pawn that was captured via en passant
          const capturedPawnRow = currentPlayer === "white" ? toRow + 1 : toRow - 1;

          // Add the captured en passant pawn to captured pieces
          const capturedPawn = newBoardState[capturedPawnRow][toCol];
          if (capturedPawn) {
            if (currentPlayer === "white") {
              capturedPieces.white.push(capturedPawn);
            } else {
              capturedPieces.black.push(capturedPawn);
            }
          }

          newBoardState[capturedPawnRow][toCol] = null;
        }

        // Set new en passant target if a pawn moved two squares
        if (piece.toLowerCase() === "p" && Math.abs(toRow - fromRow) === 2) {
          // The en passant target is the square that was skipped
          const enPassantRow = (fromRow + toRow) / 2;
          enPassantTarget = [enPassantRow, toCol];
        } else {
          enPassantTarget = null; // Clear en passant target for other moves
        }

        // Handle pawn promotion
        if (piece.toLowerCase() === "p" && (toRow === 0 || toRow === 7)) {
          // Auto-promote to queen for simplicity
          newBoardState[toRow][toCol] = currentPlayer === "white" ? "Q" : "q";
        }

        // Update board state
        boardState = newBoardState;

        // Record move in PGN-like format
        const cols = ["a", "b", "c", "d", "e", "f", "g", "h"];
        const from = cols[fromCol] + (8 - fromRow);
        const to = cols[toCol] + (8 - toRow);
        const moveNotation = from + to;

        moveHistory.push(moveNotation);

        // Update PGN output after every move
        const pgnOutput = document.getElementById("pgn-output");
        if (pgnOutput) {
          pgnOutput.textContent =
            "PGN: " + moveHistory.map((m, i) => (i % 2 === 0 ? `${Math.floor(i / 2) + 1}.` : "") + m).join(" ");
        }

        // Store last move for highlighting
        lastMove = {
          from: [fromRow, fromCol],
          to: [toRow, toCol],
        };

        // Switch to the other player
        currentPlayer = currentPlayer === "white" ? "black" : "white";

        // Track position for 3-fold repetition
        const boardKey = getBoardKey(boardState, currentPlayer);
        positionCounts[boardKey] = (positionCounts[boardKey] || 0) + 1;

        // Check for 3-fold repetition
        function isThreefoldRepetition() {
          const boardKey = getBoardKey(boardState, currentPlayer);
          return positionCounts[boardKey] >= 3;
        }

        // Check for 50-move rule
        function isFiftyMoveRule() {
          return halfMoveClock >= 100;
        }

        // Check for check or checkmate
        const inCheck = isInCheck(currentPlayer, boardState);
        debugLog(`Is ${currentPlayer} in check after move? ${inCheck}`);

        if (isCheckmate(currentPlayer, boardState)) {
          debugLog(`CHECKMATE detected for ${currentPlayer}`);
          gameStatus = "checkmate";
          drawReason = null;
          // Show PGN in console and update display
          console.log("PGN:", moveHistory.join(" "));

          const pgnOutput = document.getElementById("pgn-output");
          if (pgnOutput) {
            pgnOutput.textContent = "PGN: " + moveHistory.join(" ");
          }
        } else if (isStalemate(currentPlayer, boardState)) {
          gameStatus = "draw";
          drawReason = "stalemate";
        } else if (isFiftyMoveRule()) {
          gameStatus = "draw";
          drawReason = "50move";
        } else if (isThreefoldRepetition()) {
          gameStatus = "draw";
          drawReason = "repetition";
        } else if (isInCheck(currentPlayer, boardState)) {
          debugLog(`CHECK detected for ${currentPlayer}`);
          gameStatus = "check";
        } else {
          gameStatus = "playing";
        }

        // Check for stalemate
        function isStalemate(playerColor, boardState) {
          if (isInCheck(playerColor, boardState)) return false;

          // Try all legal moves for the player
          for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
              const piece = boardState[row][col];
              if (piece && getPieceColor(piece) === playerColor) {
                const moves = getValidMoves(row, col, piece, boardState, enPassantTarget);
                const legalMoves = moves.filter(([toRow, toCol]) => {
                  return !wouldBeInCheck(row, col, toRow, toCol, piece, boardState);
                });
                if (legalMoves.length > 0) {
                  return false; // At least one legal move exists
                }
              }
            }
          }

          return true; // No legal moves and not in check
        }

        // Trigger haptic feedback when a piece is moved
        triggerHapticFeedback();

        // Update the UI
        renderBoard();

        // Return success
        return true;
      }

      // Handle square clicks for moving pieces
      function handleSquareClick(row, col) {
        // Don't allow moves if the game is in checkmate
        if (gameStatus === "checkmate") {
          return;
        }

        // If no piece is selected, try to select one
        if (!selectedPiece) {
          const piece = boardState[row][col];

          // Can only select pieces of the current player's color
          if (piece && getPieceColor(piece) === currentPlayer) {
            selectedPiece = { row, col, piece };

            // Calculate valid moves for the selected piece
            validMoves = getValidMoves(row, col, piece, boardState, enPassantTarget).filter(([toRow, toCol]) => {
              // Filter out moves that would put the king in check
              return !wouldBeInCheck(row, col, toRow, toCol, piece, boardState);
            });

            renderBoard();
          }
          return;
        }

        // If a piece is already selected
        const { row: fromRow, col: fromCol, piece } = selectedPiece;

        // Check if the clicked square is a valid move
        const moveIndex = validMoves.findIndex(([r, c]) => r === row && c === col);

        if (moveIndex >= 0) {
          // Move the piece using the common function
          movePiece(fromRow, fromCol, row, col);

          // Clear selection and valid moves
          selectedPiece = null;
          validMoves = [];

          // If the game is in AI mode and it's AI's turn, make the AI move
          if (gameMode === "ai" && currentPlayer === aiColor && gameStatus !== "checkmate") {
            makeAIMove();
          }
        } else {
          // If the clicked square is not a valid move

          // If clicking on another one of the player's pieces, select that piece instead
          const targetPiece = boardState[row][col];
          if (targetPiece && getPieceColor(targetPiece) === currentPlayer) {
            selectedPiece = { row, col, piece: targetPiece };
            validMoves = getValidMoves(row, col, targetPiece, boardState, enPassantTarget).filter(([toRow, toCol]) => {
              return !wouldBeInCheck(row, col, toRow, toCol, targetPiece, boardState);
            });
          } else {
            // Otherwise, deselect
            selectedPiece = null;
            validMoves = [];
          }

          renderBoard();
        }
      }

      // Piece values are defined later in the code

      // Update the game status display
      function updateGameStatus() {
        currentPlayerElement.textContent = currentPlayer.toUpperCase();
        gameStatusElement.textContent = gameStatus.toUpperCase();

        if (gameStatus === "checkmate") {
          const winner = currentPlayer === "white" ? "BLACK" : "WHITE";
          const winnerElement = document.createElement("div");
          winnerElement.className = "winner";
          winnerElement.textContent = `${winner} WINS!`;
          gameStatusElement.appendChild(winnerElement);

          // Calculate score for Farcade SDK
          // 2 points for checkmate, 1 point for draw, 0 for loss
          if (
            (winner === "WHITE" && gameMode === "ai" && aiColor === "black") ||
            (winner === "BLACK" && gameMode === "ai" && aiColor === "white")
          ) {
            // Player won against AI
            gameScore = 2;
          } else if (gameMode === "ai") {
            // Player lost against AI
            gameScore = 0;
          }
        }

        if (gameStatus === "draw") {
          const drawElement = document.createElement("div");
          drawElement.className = "winner";

          if (drawReason === "stalemate") {
            drawElement.textContent = "STALEMATE";
          } else if (drawReason === "50move") {
            drawElement.textContent = "50 MOVES";
          } else if (drawReason === "repetition") {
            drawElement.textContent = "REPETITION";
          } else {
            drawElement.textContent = "DRAW";
          }

          gameStatusElement.appendChild(drawElement);
          gameScore = 1;
        }

        // Add game over overlay with Submit Score button
        if (gameStatus === "checkmate" || gameStatus === "draw") {
          const overlay = document.createElement("div");
          overlay.className = "checkmate-overlay";

          const content = document.createElement("div");
          content.style.display = "flex";
          content.style.flexDirection = "column";
          content.style.alignItems = "center";
          content.style.gap = "10px";

          const title = document.createElement("div");
          title.className = "checkmate-text";
          title.textContent = gameStatus === "checkmate" ? "CHECKMATE" : "DRAW";

          const subtext = document.createElement("div");
          subtext.className = "scoreboard-text";
          if (gameStatus === "draw") {
            if (drawReason === "50move") subtext.textContent = "50 moves without a capture or pawn move";
            else if (drawReason === "repetition") subtext.textContent = "Same position repeated 3 times";
            else if (drawReason === "stalemate") subtext.textContent = "Stalemate";
          }

          const buttonContainer = document.createElement("div");
          buttonContainer.style.display = "flex";
          buttonContainer.style.gap = "10px";

          const newGameButton = document.createElement("button");
          newGameButton.className = "modal-button";
          newGameButton.textContent = "NEW GAME";
          newGameButton.id = "new-game-checkmate";
          newGameButton.addEventListener("click", resetGame);

          const submitScoreButton = document.createElement("button");
          submitScoreButton.className = "modal-button";
          submitScoreButton.textContent = "SUBMIT SCORE";
          submitScoreButton.addEventListener("click", () => {
            // Call Farcade SDK gameOver
            updateFarcadeScore();
            // Remove Submit Score button after submission
            submitScoreButton.style.display = "none";
          });

          content.appendChild(title);
          if (subtext.textContent) content.appendChild(subtext);
          buttonContainer.appendChild(newGameButton);
          buttonContainer.appendChild(submitScoreButton);
          content.appendChild(buttonContainer);
          overlay.appendChild(content);
          boardElement.appendChild(overlay);

          triggerHapticFeedback();
        }
      }

      // Calculate the score difference between captured pieces
      function calculateScoreDifference() {
        let whiteScore = 0;
        let blackScore = 0;

        // Calculate score from captured pieces
        capturedPieces.white.forEach((piece) => {
          whiteScore += pieceValues[piece.toLowerCase()];
        });

        capturedPieces.black.forEach((piece) => {
          blackScore += pieceValues[piece.toLowerCase()];
        });

        return { whiteScore, blackScore };
      }

      // Update the captured pieces display
      function updateCapturedPieces() {
        // Clear current display
        whiteCapturedElement.innerHTML = "";
        blackCapturedElement.innerHTML = "";

        // Add each captured piece to the display
        capturedPieces.white.forEach((piece) => {
          const pieceSpan = document.createElement("span");
          pieceSpan.textContent = pieceMapping[piece];
          pieceSpan.className = "black-piece"; // These are black pieces captured by white
          whiteCapturedElement.appendChild(pieceSpan);
        });

        capturedPieces.black.forEach((piece) => {
          const pieceSpan = document.createElement("span");
          pieceSpan.textContent = pieceMapping[piece];
          pieceSpan.className = "white-piece"; // These are white pieces captured by black
          blackCapturedElement.appendChild(pieceSpan);
        });

        // Update score display
        const { whiteScore, blackScore } = calculateScoreDifference();

        if (whiteScore > blackScore) {
          whiteScoreElement.textContent = `+${whiteScore - blackScore}`;
          blackScoreElement.textContent = "+0";
        } else if (blackScore > whiteScore) {
          blackScoreElement.textContent = `+${blackScore - whiteScore}`;
          whiteScoreElement.textContent = "+0";
        } else {
          whiteScoreElement.textContent = "+0";
          blackScoreElement.textContent = "+0";
        }
      }

      // AI OPPONENT FUNCTIONS

      // Get all valid moves for all pieces of a specific color
      function getAllPossibleMoves(color, boardState) {
        const moves = [];

        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            const piece = boardState[row][col];
            if (piece && getPieceColor(piece) === color) {
              const pieceMoves = getValidMoves(row, col, piece, boardState, enPassantTarget);

              // Filter out moves that would leave the king in check
              const legalMoves = pieceMoves.filter(([toRow, toCol]) => {
                return !wouldBeInCheck(row, col, toRow, toCol, piece, boardState);
              });

              legalMoves.forEach(([toRow, toCol]) => {
                moves.push({
                  piece,
                  from: [row, col],
                  to: [toRow, toCol],
                });
              });
            }
          }
        }

        return moves;
      }

      // Calculate piece values for board evaluation
      const pieceValues = {
        p: 1, // pawn
        n: 3, // knight
        b: 3, // bishop
        r: 5, // rook
        q: 9, // queen
        k: 0, // king (not factored in material evaluation)
      };

      // Calculate material score for a given board state
      function calculateMaterialScore(boardState) {
        let whiteScore = 0;
        let blackScore = 0;

        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            const piece = boardState[row][col];
            if (piece) {
              const pieceType = piece.toLowerCase();
              const value = pieceValues[pieceType];

              if (getPieceColor(piece) === "white") {
                whiteScore += value;
              } else {
                blackScore += value;
              }
            }
          }
        }

        return whiteScore - blackScore; // Positive is good for white, negative for black
      }

      // Position evaluation bonuses - encourage control of center and development
      const positionBonus = {
        // Pawns - encourage center control and advancement
        p: [
          [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
          [5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0], // Big bonus for promoting
          [1.0, 1.0, 2.0, 3.0, 3.0, 2.0, 1.0, 1.0],
          [0.5, 0.5, 1.0, 2.5, 2.5, 1.0, 0.5, 0.5],
          [0.0, 0.0, 0.0, 2.0, 2.0, 0.0, 0.0, 0.0],
          [0.5, -0.5, -1.0, 0.0, 0.0, -1.0, -0.5, 0.5], // Discourage backward pawns
          [0.5, 1.0, 1.0, -2.0, -2.0, 1.0, 1.0, 0.5], // Encourage pawn structure
          [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
        ],
        // Knights - encourage central control and development
        n: [
          [-5.0, -4.0, -3.0, -3.0, -3.0, -3.0, -4.0, -5.0],
          [-4.0, -2.0, 0.0, 0.0, 0.0, 0.0, -2.0, -4.0],
          [-3.0, 0.0, 1.0, 1.5, 1.5, 1.0, 0.0, -3.0],
          [-3.0, 0.5, 1.5, 2.0, 2.0, 1.5, 0.5, -3.0],
          [-3.0, 0.0, 1.5, 2.0, 2.0, 1.5, 0.0, -3.0],
          [-3.0, 0.5, 1.0, 1.5, 1.5, 1.0, 0.5, -3.0],
          [-4.0, -2.0, 0.0, 0.5, 0.5, 0.0, -2.0, -4.0],
          [-5.0, -4.0, -3.0, -3.0, -3.0, -3.0, -4.0, -5.0]
        ],
        // Bishops - encourage diagonal control and development
        b: [
          [-2.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -2.0],
          [-1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0],
          [-1.0, 0.0, 0.5, 1.0, 1.0, 0.5, 0.0, -1.0],
          [-1.0, 0.5, 0.5, 1.0, 1.0, 0.5, 0.5, -1.0],
          [-1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, -1.0],
          [-1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0],
          [-1.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, -1.0],
          [-2.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -2.0]
        ],
        // Rooks - encourage open files and 7th rank
        r: [
          [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
          [0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.5],
          [-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5],
          [-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5],
          [-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5],
          [-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5],
          [-0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5],
          [0.0, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0]
        ],
        // Queen - slight center preference
        q: [
          [-2.0, -1.0, -1.0, -0.5, -0.5, -1.0, -1.0, -2.0],
          [-1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0],
          [-1.0, 0.0, 0.5, 0.5, 0.5, 0.5, 0.0, -1.0],
          [-0.5, 0.0, 0.5, 0.5, 0.5, 0.5, 0.0, -0.5],
          [0.0, 0.0, 0.5, 0.5, 0.5, 0.5, 0.0, -0.5],
          [-1.0, 0.5, 0.5, 0.5, 0.5, 0.5, 0.0, -1.0],
          [-1.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, -1.0],
          [-2.0, -1.0, -1.0, -0.5, -0.5, -1.0, -1.0, -2.0]
        ],
        // King - encourage castling and king safety
        k: [
          [-3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0],
          [-3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0],
          [-3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0],
          [-3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0],
          [-2.0, -3.0, -3.0, -4.0, -4.0, -3.0, -3.0, -2.0],
          [-1.0, -2.0, -2.0, -2.0, -2.0, -2.0, -2.0, -1.0],
          [2.0, 2.0, 0.0, 0.0, 0.0, 0.0, 2.0, 2.0],
          [2.0, 3.0, 1.0, 0.0, 0.0, 1.0, 3.0, 2.0]
        ],
      };

      // Calculate position score for a given board state
      function calculatePositionScore(boardState) {
        let whiteScore = 0;
        let blackScore = 0;

        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            const piece = boardState[row][col];
            if (piece) {
              const pieceType = piece.toLowerCase();

              if (getPieceColor(piece) === "white") {
                // For white pieces, row 7 is the bottom, so we invert the row index
                whiteScore += positionBonus[pieceType][row][col];
              } else {
                // For black pieces, row 0 is the bottom from its perspective
                blackScore += positionBonus[pieceType][7 - row][col];
              }
            }
          }
        }

        return whiteScore - blackScore; // Positive is good for white, negative for black
      }

      // Make AI move with weighted randomness
      function makeAIMove() {
        // Prevent AI move if game is over or it's not AI's turn or AI is already thinking
        if (aiThinking || (gameStatus !== "playing" && gameStatus !== "check") || currentPlayer !== aiColor) {
          debugLog("AI move cancelled or not AI turn:", { aiThinking, gameStatus, currentPlayer, aiColor });
          // Ensure thinking flag is false if cancelled here
          if (gameStatus === "checkmate" || gameStatus === "draw") aiThinking = false;
          return;
        }

        debugLog("AI starting move evaluation");
        aiThinking = true;
        selectedPiece = null; // Ensure no piece selection interferes
        validMoves = []; // Clear any leftover valid moves display

        // Use setTimeout to simulate thinking time and prevent blocking the UI thread
        setTimeout(() => {
          // Double-check game status hasn't changed while waiting and it's still AI's turn
          if ((gameStatus !== "playing" && gameStatus !== "check") || currentPlayer !== aiColor) {
            debugLog("AI move aborted, game ended or turn changed during thinking time.");
            aiThinking = false;
            renderBoard(); // Re-render to show final state if needed
            return;
          }

          // Get all *strictly legal* moves (should filter moves into check)
          const possibleMoves = getAllPossibleMoves(aiColor, boardState);
          debugLog(`AI found ${possibleMoves.length} possible moves initially`);

          // ***** NEW STALEMATE/CHECKMATE CHECK *****
          if (possibleMoves.length === 0) {
            if (isInCheck(aiColor, boardState)) {
              // No legal moves AND in check = Checkmate
              debugLog(`AI found 0 moves and is in check. CHECKMATE.`);
              gameStatus = "checkmate";
              // Optional: Update score if tracking vs AI
              gameScore = 0; // Player wins if AI is checkmated
              updateFarcadeScore();
            } else {
              // No legal moves AND NOT in check = Stalemate
              debugLog(`AI found 0 moves and is NOT in check. STALEMATE.`);
              gameStatus = "draw";
              drawReason = "stalemate";
              // Optional: Update score if tracking vs AI
              gameScore = 1; // Draw score
              updateFarcadeScore();
            }
            aiThinking = false;
            renderBoard(); // Update UI to show Checkmate/Stalemate overlay
            return; // Stop further processing for this turn
          }
          // ***** END OF NEW CHECK *****

          // If we reach here, there are possible moves, proceed with evaluation...
          const evaluatedMoves = possibleMoves.map((move) => {
            // Create a temporary board state to simulate the move
            const tempBoard = JSON.parse(JSON.stringify(boardState));
            tempBoard[move.to[0]][move.to[1]] = move.piece;
            tempBoard[move.from[0]][move.from[1]] = null;

            // Although getAllPossibleMoves should filter checks, we double-check here
            // to assign the -1000 score for the filtering step below.
            if (isInCheck(aiColor, tempBoard)) {
              debugLog(`Move (${move.from.join(",")}) to (${move.to.join(",")}) results in check - scoring -1000`);
              return { ...move, score: -1000 };
            }

            // Evaluate the board *after* the potential move
            // Score is relative to white. If AI is black, negate the score.
            const boardScore = evaluateBoard(tempBoard);
            const score = aiColor === "black" ? -boardScore : boardScore;

            // Simple bonus for captures to encourage taking pieces
            const isCapture = boardState[move.to[0]][move.to[1]] !== null;
            const captureBonus = isCapture ? pieceValues[boardState[move.to[0]][move.to[1]].toLowerCase()] || 0.5 : 0; // Bonus based on captured piece value or default 0.5

            return { ...move, score: score + captureBonus };
          });

          // Sort moves: Best score first
          evaluatedMoves.sort((a, b) => b.score - a.score);
          // Only log top 5 for brevity if many moves
          // debugLog("AI evaluated moves (Top 5):", evaluatedMoves.slice(0, 5));

          // Filter out any moves that somehow still resulted in check (score -1000)
          // This relies on the isInCheck call within the map function above working correctly.
          const filteredMoves = evaluatedMoves.filter((m) => m.score > -1000);
          debugLog(`AI has ${filteredMoves.length} valid moves after filtering checks.`);

          // This should not happen if the initial possibleMoves.length check is working
          if (filteredMoves.length === 0) {
            console.error(
              "AI Error: No valid moves after filtering, but initial possibleMoves > 0. Check evaluation/filtering logic.",
            );
            aiThinking = false;
            renderBoard(); // Re-render current state
            return;
          }

          // --- Improved Move Selection Logic ---
          let selectedMove;
          // Consider only the top 25% of moves (reduced from 40% for more focus on better moves)
          const goodMovesCount = Math.max(1, Math.floor(filteredMoves.length * 0.25));
          const weights = [];
          let totalWeight = 0;

          // Assign more aggressive exponential weighting to prefer better moves
          for (let i = 0; i < goodMovesCount; i++) {
              if (i < filteredMoves.length) {
                  const weight = Math.pow(0.6, i); // Changed from 0.8 to 0.6 for stronger preference of better moves
                  weights.push(weight);
                  totalWeight += weight;
              } else {
                  break;
              }
          }

          // Small chance (10%) to pick the absolute best move
          if (Math.random() < 0.1) {
              selectedMove = filteredMoves[0];
          } else {
              // Otherwise use weighted random selection
              const randomValue = Math.random() * totalWeight;
              let cumulativeWeight = 0;
              for (let i = 0; i < goodMovesCount; i++) {
                  if (i < filteredMoves.length && i < weights.length) {
                      cumulativeWeight += weights[i];
                      if (randomValue <= cumulativeWeight) {
                          selectedMove = filteredMoves[i];
                          break;
                      }
                  }
              }
          }

          // Fallback to best move if no selection was made
          if (!selectedMove) {
              selectedMove = filteredMoves[0];
          }
          // --- End of Improved Selection Logic ---

          // Ensure a move was actually selected
          if (!selectedMove) {
            console.error("AI Critical Error: Could not select a move despite having valid options.");
            aiThinking = false;
            return;
          }

          const [fromRow, fromCol] = selectedMove.from;
          const [toRow, toCol] = selectedMove.to;
          const pieceToMove = boardState[fromRow][fromCol]; // Get piece before simulation for sanity check

          // --- Final Sanity Check (Optional but recommended) ---
          // Verify the chosen move doesn't put the AI in check *just before* executing it.
          if (!pieceToMove) {
            console.error(
              `!!! AI Critical Error: Trying to move null piece from (${fromRow},${fromCol}) !!!`,
              selectedMove,
            );
            aiThinking = false;
            return;
          }
          if (wouldBeInCheck(fromRow, fromCol, toRow, toCol, pieceToMove, boardState)) {
            console.error(
              `!!! AI Critical Error: Chosen move from (${fromRow},${fromCol}) to (${toRow},${toCol}) results in check despite filtering !!!`,
              selectedMove,
            );
            debugLog("All filtered moves were:", filteredMoves);
            // If this happens, perhaps force pick the next best move if available? For now, just stop.
            aiThinking = false;
            return;
          }
          // --- End Sanity Check ---

          debugLog("AI selected move:", selectedMove);

          // Execute the chosen move
          // movePiece handles board update, state changes, and calls renderBoard()
          movePiece(fromRow, fromCol, toRow, toCol);

          aiThinking = false; // AI is done thinking

          // Note: renderBoard() and updateGameStatus() are called inside movePiece
        }, 500); // AI "thinking" delay in milliseconds
      }

      // Reset the game to the initial state
      function resetGame() {
        boardState = JSON.parse(JSON.stringify(initialBoardState));
        selectedPiece = null;
        currentPlayer = "white";
        gameStatus = "playing";
        validMoves = [];
        lastMove = { from: null, to: null };
        enPassantTarget = null;
        aiThinking = false; // Reset AI thinking state
        gameScore = 0; // Reset the Farcade score
        moveHistory = [];
        halfMoveClock = 0; // Reset the 50-move rule counter
        positionCounts = {}; // Reset the position counts for repetition detection

        // Clear PGN display
        const pgnOutput = document.getElementById("pgn-output");
        if (pgnOutput) {
          pgnOutput.textContent = "";
        }

        // Reset captured pieces
        capturedPieces = {
          white: [],
          black: [],
        };

        castlingRights = {
          whiteKingSide: true,
          whiteQueenSide: true,
          blackKingSide: true,
          blackQueenSide: true,
        };

        renderBoard();
        updateGameStatus();
        updateCapturedPieces();

        // If it's an AI game and AI plays as white, make the first move
        if (gameMode === "ai" && aiColor === "white") {
          setTimeout(() => {
            makeAIMove();
          }, 500); // Small delay for better user experience
        }
      }

      // Event listeners
      // Modal controls
      menuButton.addEventListener("click", () => {
        menuModal.classList.add("active");

        // Update the UI to reflect current game mode
        document.getElementById(gameMode === "human" ? "mode-human" : "mode-ai").classList.add("active");
        document.getElementById(gameMode === "human" ? "mode-ai" : "mode-human").classList.remove("active");

        // Show/hide AI options based on game mode
        aiOptionsContainer.style.display = gameMode === "ai" ? "block" : "none";

        // Update AI color selection UI to match current aiColor setting
        if (aiColor === "black") {
          aiColorWhiteButton.classList.add("active");
          aiColorBlackButton.classList.remove("active");
        } else {
          aiColorBlackButton.classList.add("active");
          aiColorWhiteButton.classList.remove("active");
        }
      });

      closeModalButton.addEventListener("click", () => {
        menuModal.classList.remove("active");
      });

      // Game mode selection
      const modeHumanButton = document.getElementById("mode-human");
      const modeAIButton = document.getElementById("mode-ai");

      // Get references to the new AI option elements
      const aiOptionsContainer = document.getElementById("ai-options");
      const aiColorWhiteButton = document.getElementById("ai-color-white");
      const aiColorBlackButton = document.getElementById("ai-color-black");

      // Human mode button event handler
      modeHumanButton.addEventListener("click", () => {
        gameMode = "human";
        modeHumanButton.classList.add("active");
        modeAIButton.classList.remove("active");
        aiOptionsContainer.style.display = "none"; // Hide AI options
      });

      // AI mode button event handler
      modeAIButton.addEventListener("click", () => {
        gameMode = "ai";
        modeAIButton.classList.add("active");
        modeHumanButton.classList.remove("active");
        aiOptionsContainer.style.display = "block"; // Show AI options
      });

      // AI color selection: white
      aiColorWhiteButton.addEventListener("click", () => {
        aiColor = "black"; // AI plays as black
        aiColorWhiteButton.classList.add("active");
        aiColorBlackButton.classList.remove("active");
      });

      // AI color selection: black
      aiColorBlackButton.addEventListener("click", () => {
        aiColor = "white"; // AI plays as white
        aiColorBlackButton.classList.add("active");
        aiColorWhiteButton.classList.remove("active");
      });

      newGameModalButton.addEventListener("click", () => {
        resetGame();
        menuModal.classList.remove("active");
      });

      // Initialize the game
      renderBoard();
      updateGameStatus();
      updateCapturedPieces();

      // Set initial UI state for AI options
      aiOptionsContainer.style.display = gameMode === "ai" ? "block" : "none";

      // Set initial button states to match default game mode
      if (gameMode === "ai") {
        modeAIButton.classList.add("active");
        modeHumanButton.classList.remove("active");
      } else {
        modeHumanButton.classList.add("active");
        modeAIButton.classList.remove("active");
      }

      // Set AI color button states
      if (aiColor === "black") {
        aiColorWhiteButton.classList.add("active");
        aiColorBlackButton.classList.remove("active");
      } else {
        aiColorBlackButton.classList.add("active");
        aiColorWhiteButton.classList.remove("active");
      }

             // Farcade SDK Integration

      // Initialize SDK when the game is fully loaded and ready to play
      window.addEventListener("DOMContentLoaded", () => {
        if (window.FarcadeSDK) {
          // Signal that the game is ready to play
          window.FarcadeSDK.singlePlayer.actions.ready();

          // Set up event handlers for Farcade SDK events

          // Handle play_again event
          window.FarcadeSDK.on("play_again", () => {
            // Reset the game state
            resetGame();
          });

          // Handle toggle_mute event
          window.FarcadeSDK.on("toggle_mute", (data) => {
            // Set game audio based on data.isMuted
            isMuted = data.isMuted;
            // Future audio can check isMuted before playing
          });
        }
      });

      // Function to send score to Farcade SDK
      function updateFarcadeScore() {
        if (window.FarcadeSDK) {
          window.FarcadeSDK.singlePlayer.actions.gameOver({
            score: gameScore,
          });
        }
      }

      // Function to trigger haptic feedback
      function triggerHapticFeedback() {
        if (window.FarcadeSDK) {
          window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
        }
      }

      // Touch event handlers for the entire board
      let activeGhost = null;
      let isPieceBeingDragged = false;

      boardElement.addEventListener("touchstart", (e) => {
        debugLog("Touch start event triggered");
        if (gameStatus === "checkmate" || aiThinking) {
          debugLog("Touch ignored - game over or AI thinking");
          return;
        }

        const touch = e.touches[0];
        const element = document.elementFromPoint(touch.clientX, touch.clientY);
        debugLog("Touch target:", element?.className);

        if (!element || !element.classList.contains("piece")) return;

        const square = element.parentElement;
        const row = parseInt(square.dataset.row);
        const col = parseInt(square.dataset.col);
        const piece = boardState[row][col];

        if (!piece || getPieceColor(piece) !== currentPlayer) return;

        e.preventDefault();
        isPieceBeingDragged = true;

        // Use the same selection system as click handling
        selectedPiece = { row, col, piece };
        validMoves = getValidMoves(row, col, piece, boardState, enPassantTarget).filter(([toRow, toCol]) => {
          return !wouldBeInCheck(row, col, toRow, toCol, piece, boardState);
        });

        debugLog("Valid moves for selected piece:", validMoves);

        // Create ghost piece
        activeGhost = element.cloneNode(true);
        activeGhost.classList.add("ghost-piece");
        activeGhost.style.left = `${touch.clientX}px`;
        activeGhost.style.top = `${touch.clientY}px`;
        document.body.appendChild(activeGhost);

        // Add dragging state to original piece
        element.classList.add("dragging");

        // Highlight valid moves
        validMoves.forEach(([r, c]) => {
          const targetSquare = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
          if (targetSquare) {
            if (boardState[r][c] && getPieceColor(boardState[r][c]) !== currentPlayer) {
              targetSquare.classList.add("capture-highlight");
            } else {
              targetSquare.classList.add("valid-drop");
            }
          }
        });
      });

      document.addEventListener("touchmove", (e) => {
        if (!activeGhost || !isPieceBeingDragged) return;

        e.preventDefault();
        const touch = e.touches[0];
        activeGhost.style.left = `${touch.clientX}px`;
        activeGhost.style.top = `${touch.clientY}px`;

        // Update highlights based on current touch position
        const targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
        if (targetElement) {
          const square = targetElement.closest(".square");
          if (square) {
            const row = parseInt(square.dataset.row);
            const col = parseInt(square.dataset.col);

            // Remove all current highlights
            document.querySelectorAll(".square").forEach((square) => {
              square.classList.remove("valid-drop", "capture-highlight");
            });

            // Add appropriate highlight if it's a valid move
            if (validMoves.some(([r, c]) => r === row && c === col)) {
              debugLog("Valid drop target found:", { row, col });
              if (boardState[row][col] && getPieceColor(boardState[row][col]) !== currentPlayer) {
                square.classList.add("capture-highlight");
              } else {
                square.classList.add("valid-drop");
              }
            }
          }
        }
      });

      document.addEventListener("touchend", (e) => {
        if (!activeGhost || !isPieceBeingDragged || !selectedPiece) return;

        e.preventDefault();
        isPieceBeingDragged = false;

        // Clean up ghost piece
        document.body.removeChild(activeGhost);
        activeGhost = null;

        // Remove dragging state and highlights
        document.querySelector(".piece.dragging")?.classList.remove("dragging");
        document.querySelectorAll(".square").forEach((square) => {
          square.classList.remove("valid-drop", "capture-highlight");
        });

        const touch = e.changedTouches[0];
        let targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
        let square = targetElement?.closest(".square");

        if (square && gameStatus !== "checkmate" && !aiThinking) {
          const toRow = parseInt(square.dataset.row);
          const toCol = parseInt(square.dataset.col);
          const { row: fromRow, col: fromCol } = selectedPiece;

          const isValid = validMoves.some(([r, c]) => r === toRow && c === toCol);
          debugLog("Attempting move:", { fromRow, fromCol, toRow, toCol, isValid });

          if (isValid) {
            const isCapture = boardState[toRow][toCol] !== null;
            if (isCapture) {
              square.classList.add("capture-highlight");
            }

            const moveSucceeded = movePiece(fromRow, fromCol, toRow, toCol);
            debugLog("Move result:", moveSucceeded);

            if (moveSucceeded) {
              // Clear selection and valid moves immediately
              selectedPiece = null;
              validMoves = [];
              renderBoard();

              // Remove capture highlight after animation
              if (isCapture) {
                setTimeout(() => {
                  square.classList.remove("capture-highlight");
                }, 300);
              }

              // If it's an AI game and it's AI's turn, schedule the AI move
              if (gameMode === "ai" && currentPlayer === aiColor && gameStatus !== "checkmate") {
                debugLog("Scheduling AI move...");
                setTimeout(() => {
                  if (gameStatus !== "checkmate") {
                    makeAIMove();
                  }
                }, 500);
              }
            }
          }
        }

        // Clear selection state
        selectedPiece = null;
        validMoves = [];
        renderBoard();
      });
    </script>
  </body>
</html>
