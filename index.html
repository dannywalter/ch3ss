<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>CH3SS</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=block" rel="stylesheet" />
  <script src="https://unpkg.com/@farcade/game-sdk@latest/dist/index.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.js"></script>

  <!-- Background music element -->
  <audio id="background-music" loop preload="auto">
    <source src="https://dannywalter.github.io/ch3ss-puzzles/checkmate-in-neon-extended.mp3" type="audio/mpeg" />
  </audio>
  <style>
    /* Global Styles */
    *,
    *::before,
    *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      -webkit-touch-callout: none;
      /* iOS Safari */
      -webkit-user-select: none;
      /* Safari */
      -khtml-user-select: none;
      /* Konqueror HTML */
      -moz-user-select: none;
      /* Firefox */
      -ms-user-select: none;
      /* Internet Explorer/Edge */
      user-select: none;
      /* Non-prefixed version, supported by Chrome and Opera */
    }

    html {
      -webkit-text-size-adjust: none;
      text-size-adjust: none;
    }

    body {
      width: 100%;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: linear-gradient(135deg, #120025 0%, #050520 100%);
      font-family: "Press Start 2P", monospace;
      color: #00ffff;
      overflow: hidden;
      padding: 0px;
    }

    /* Arcade Cabinet Styling - Mobile First Approach */
    .arcade {
      max-width: 400px;
      max-height: 800px;
      width: 100%;
      height: auto;
      padding: 5px;
      border-radius: 10px;
      box-shadow:
        0 0 20px #ff00ff,
        0 0 30px rgba(0, 255, 255, 0.5) inset;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #ff00ff;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      /* Logical canvas size for game elements */
      --canvas-width: 500px;
      --canvas-height: 800px;
      aspect-ratio: 500 / 800;
    }

    .title {
      text-align: center;
      font-size: 1.5rem;
      margin: 10px 0 10px 0;
      text-shadow:
        0 0 5px #00ffff,
        0 0 10px #00ffff;
      letter-spacing: 0.1em;
      color: #ffffff;
    }

    /* Game Area */
    .game-area {
      display: flex;
      flex-direction: column;
      gap: 15px;
      justify-content: center;
      align-items: center;
      width: 100%;
    }

    /* Board Styling - Responsive */
    .board {
      display: flex;
      flex-direction: column;
      border: 2px solid #00ffff;
      box-shadow:
        0 0 15px #00ffff,
        0 0 5px rgba(0, 255, 255, 0.5) inset;
      position: relative;
      width: 100%;
      max-width: 360px;
      /* Maximized size for 400px container width */
      margin: 0 auto;
      touch-action: none;
    }

    .row {
      display: flex;
      width: 100%;
    }

    .square {
      width: 12.5%;
      /* 100% ÷ 8 squares */
      position: relative;
      padding-bottom: 12.5%;
      /* Makes squares perfect */
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .piece {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80%;
      /* Percentage of square size */
      height: 80%;
      /* Maintain aspect ratio */
      display: flex;
      justify-content: center;
      align-items: center;
      user-select: none;
      -webkit-user-select: none;
      -ms-user-select: none;
      /* Use viewport-relative font sizing with a minimum */
      font-size: clamp(16px, 4.5vmin, 32px);
      line-height: 1;
      cursor: grab;
    }

    .light-square {
      background: #00ffff10;
      box-shadow: 0 0 5px #00ffff inset;
    }

    .dark-square {
      background: #00000080;
    }

    .selected {
      background: #ff00ff80 !important;
      box-shadow:
        0 0 15px #ff00ff,
        0 0 5px #ff00ff inset !important;
    }

    .last-move-from {
      background: rgba(255, 255, 255, 0.1) !important;
      box-shadow: 0 0 10px #ffffff inset !important;
    }

    .last-move-to {
      box-shadow:
        0 0 20px rgba(255, 255, 255, 1),
        0 0 5px rgba(255, 255, 255, 1) inset !important;
    }

    .valid-move {
      background: #00ff0040 !important;
      box-shadow:
        0 0 15px #00ff00,
        0 0 5px #00ff00 inset !important;
    }

    .white-piece {
      color: #ffffff;
      text-shadow:
        0 0 5px #00ffff,
        0 0 10px #00ffff;
    }

    .black-piece {
      color: #ff50f0;
      text-shadow:
        0 0 5px #ff00ff,
        0 0 10px #ff00ff;
    }

    /* Game Info Panel */
    .info-container {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 5px;
      width: 100%;
      max-width: 360px;
    }

    .display {
      border: 2px solid #00ffff;
      border-radius: 5px;
      box-shadow:
        0 0 10px #00ffff,
        0 0 5px rgba(0, 255, 255, 0.3) inset;
      overflow: hidden;
    }

    .display-header {
      font-size: 0.45rem;
      background: #00ffff20;
      padding: 3px 6px;
      border-bottom: 1px solid #00ffff;
      text-align: center;
    }

    .display-content {
      font-size: 0.65rem;
      padding: 5px;
      text-align: center;
      text-shadow: 0 0 5px #00ffff;
      letter-spacing: 0.1em;
      min-height: 22px;
    }

    .info-row {
      display: flex;
      gap: 8px;
      width: 100%;
      margin-bottom: 8px;
    }

    .info-panel {
      flex: 1;
    }

    .rules-content {
      font-size: 0.45rem;
      line-height: 1.5;
      color: #ff99ff;
      text-shadow: 0 0 3px #ff00ff;
      text-align: left;
      padding: 6px;
    }

    .menu-content {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 6px;
    }

    .menu-inline-button {
      background: transparent;
      color: #ff00ff;
      border: 1px solid #ff00ff;
      padding: 4px 8px;
      font-size: 0.5rem;
      border-radius: 3px;
      cursor: pointer;
      box-shadow: 0 0 3px #ff00ff;
      font-family: "Press Start 2P", monospace;
      transition: all 0.3s ease;
      text-shadow: 0 0 3px #ff00ff;
    }

    .menu-inline-button:hover {
      background: #ff00ff20;
      box-shadow: 0 0 6px #ff00ff;
    }

    /* Captured Pieces Display */
    .captured-container {
      display: flex;
      flex-direction: column;
      gap: 8px;
      width: 100%;
    }

    .captured-display {
      display: flex;
      flex-direction: row;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      position: relative;
    }

    .captured-pieces {
      font-size: 0.6rem;
      display: flex;
      flex-wrap: wrap;
      gap: 3px;
      padding: 2px;
      min-height: 22px;
      flex: 1;
    }

    .score-display {
      font-size: 0.6rem;
      margin-left: 5px;
      margin-right: 5px;
    }

    .score-white {
      color: #ffffff;
      text-shadow: 0 0 5px #00ffff;
    }

    .score-black {
      color: #ff50f0;
      text-shadow: 0 0 5px #ff00ff;
    }

    .scoreboard {
      border: 2px solid #ff00ff;
      border-radius: 5px;
      box-shadow:
        0 0 10px #ff00ff,
        0 0 5px rgba(255, 0, 255, 0.3) inset;
      margin-top: 5px;
      overflow: hidden;
    }

    .scoreboard-text {
      font-size: 0.75rem;
      padding: 20px 50px 20px 50px;
      line-height: 2;
      color: #ff99ff;
      text-shadow: 0 0 3px #ff00ff;
      text-align: center;
    }

    .winner {
      color: #ff00ff;
      margin-top: 5px;
      font-size: 0.6rem;
      font-weight: bold;
      text-shadow:
        0 0 8px #ff00ff,
        0 0 4px #ffffff;
      animation: pulse 1.5s infinite alternate;
    }

    /* Game Controls */
    .controls {
      margin-top: 10px;
      display: flex;
      justify-content: center;
      width: 100%;
    }

    .button {
      background: transparent;
      color: #ff00ff;
      border: 2px solid #ff00ff;
      padding: 8px 15px;
      font-size: 0.7rem;
      border-radius: 5px;
      cursor: pointer;
      box-shadow: 0 0 5px #ff00ff;
      font-family: "Press Start 2P", monospace;
      transition: all 0.3s ease;
      text-shadow: 0 0 5px #ff00ff;
    }

    .button:hover,
    .button:active {
      background: #ff00ff20;
      box-shadow:
        0 0 10px #ff00ff,
        0 0 5px #ff00ff inset;
    }

    /* Modal Styles */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 100;
      animation: fadeIn 0.3s ease-in-out;
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal {
      background: #120318;
      border: 2px solid #00ffff;
      box-shadow:
        0 0 20px #00ffff,
        0 0 10px rgba(0, 255, 255, 0.5) inset;
      border-radius: 5px;
      width: 90%;
      max-width: 350px;
      max-height: 90vh;
      overflow-y: auto;
      animation: scaleIn 0.3s ease-out;
      padding: 15px;
      color: #ffffff;
    }

    .modal-header {
      font-size: 0.9rem;
      color: #00ffff;
      text-shadow: 0 0 5px #00ffff;
      text-align: center;
      margin-bottom: 15px;
      border-bottom: 1px solid #00ffff50;
      padding-bottom: 10px;
      position: relative;
      /* Add this for absolute positioning of the close button */
      display: flex;
      /* Use flex to align items */
      justify-content: center;
      /* Center the text */
      align-items: center;
      /* Vertically align items */
    }

    .modal-section {
      margin-bottom: 15px;
      border-bottom: 1px solid #ff00ff30;
      padding-bottom: 10px;
    }

    .modal-section-title {
      font-size: 0.6rem;
      color: #ff00ff;
      text-shadow: 0 0 3px #ff00ff;
      margin-bottom: 8px;
    }

    .modal-content {
      font-size: 0.5rem;
      line-height: 1.4;
      color: #dddddd;
    }

    .modal-buttons {
      display: flex;
      justify-content: space-between;
      margin-top: 15px;
    }

    .modal-button {
      background: transparent;
      border: 1px solid #00ffff;
      color: #00ffff;
      padding: 5px 10px;
      font-size: 0.5rem;
      border-radius: 3px;
      cursor: pointer;
      font-family: "Press Start 2P", monospace;
      transition: all 0.2s;
      text-shadow: 0 0 3px #00ffff;
    }

    .modal-button:hover {
      background: #00ffff20;
      box-shadow: 0 0 8px #00ffff;
    }

    .modal-button.danger {
      border-color: #ff00ff;
      color: #ff00ff;
      text-shadow: 0 0 3px #ff00ff;
    }

    .modal-button.danger:hover {
      background: #ff00ff20;
      box-shadow: 0 0 8px #ff00ff;
    }

    .modal-close-button {
      position: absolute;
      right: 5px;
      bottom: 5px;
      width: 28px;
      height: 28px;
      background: rgba(0, 255, 255, 0.1);
      border: 1px solid #00ffff;
      border-radius: 3px;
      color: #00ffff;
      font-size: 1.4rem;
      cursor: pointer;
      text-shadow: 0 0 5px #00ffff;
      transition: all 0.2s ease;
      padding: 0;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      /* Restore flexbox for centering */
      display: flex;
      justify-content: center;
      align-items: center;
      line-height: 1;
      /* Can keep or remove, flexbox handles alignment */
    }

    .modal-close-button:hover {
      background: rgba(0, 255, 255, 0.3);
      color: #ffffff;
      box-shadow: 0 0 8px #00ffff;
      text-shadow:
        0 0 8px #00ffff,
        0 0 15px #ffffff;
    }

    /* Game mode options */
    .option-group {
      margin: 10px 0;
    }

    .option-label {
      font-size: 0.45rem;
      color: #00ffff;
      margin-bottom: 5px;
    }

    .option-buttons {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .option-button {
      background: transparent;
      border: 1px solid #666;
      color: #aaa;
      padding: 4px 8px;
      font-size: 0.45rem;
      cursor: pointer;
      font-family: "Press Start 2P", monospace;
      transition: all 0.2s;
      text-align: center;
    }

    .option-button.active {
      border-color: #00ffff;
      color: #00ffff;
      box-shadow: 0 0 5px #00ffff;
    }

    .spacer-small {
      height: 10px;
    }

    @keyframes scaleIn {
      from {
        transform: scale(0.8);
        opacity: 0;
      }

      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    /* Checkmate Overlay */
    .checkmate-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10;
      animation: fadeIn 0.5s ease-in-out;
    }

    .checkmate-text {
      color: #ff00ff;
      font-size: 1.2rem;
      font-weight: bold;
      text-shadow: 0 0 10px #ff00ff;
      padding: 15px;
      border: 2px solid #ff00ff;
      border-radius: 5px;
      background: rgba(0, 0, 0, 0.8);
      box-shadow:
        0 0 20px #ff00ff,
        0 0 10px rgba(255, 0, 255, 0.5) inset;
    }

    /* Animations */
    @keyframes pulse {
      from {
        opacity: 0.7;
        text-shadow: 0 0 5px #ff00ff;
      }

      to {
        opacity: 1;
        text-shadow:
          0 0 15px #ff00ff,
          0 0 25px #ffffff;
      }
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    /* Media Queries for Responsive Design - Tablet & Desktop */
    @media (max-width: 480px) {
      .piece {
        /* Adjust for smaller screens */
        width: 75%;
        height: 75%;
        font-size: clamp(14px, 8vmin, 28px);
      }
    }

    @media screen and (-webkit-min-device-pixel-ratio: 2) {
      .piece {
        /* Adjust for high DPI screens */
        font-size: clamp(14px, 9vmin, 32px);
      }
    }

    @media screen and (-webkit-min-device-pixel-ratio: 3) {
      .piece {
        /* Adjust for even higher DPI screens (iPhone) */
        font-size: clamp(14px, 10vmin, 42px);
        top: 40%;
      }
    }

    @media (min-width: 481px) {
      .arcade {
        padding: 8px;
      }

      .title {
        font-size: 1.8rem;
        margin-bottom: 20px;
        letter-spacing: 0.2em;
      }

      .piece {
        font-size: 24px;
      }

      .display-header {
        font-size: 0.6rem;
      }

      .display-content {
        font-size: 0.8rem;
      }

      .scoreboard-text {
        font-size: 0.45rem;
        padding: 10px;
      }

      .button {
        padding: 10px 20px;
        font-size: 0.8rem;
      }
    }

    @media (min-width: 768px) {
      .game-area {
        flex-direction: row;
        justify-content: center;
        align-items: flex-start;
      }

      .info-container {
        width: 180px;
      }

      .arcade {
        display: block;
      }
    }

    /* Touch drag and drop styles */
    .ghost-piece {
      position: fixed;
      pointer-events: none;
      z-index: 1000;
      opacity: 0.8;
      transform: translate(-50%, -65%) scale(3.1);
      transition: transform 0.1s ease;
    }

    .piece.dragging {
      opacity: 0.3;
    }

    .square.valid-drop {
      background: rgba(0, 255, 0, 0.2) !important;
      box-shadow: 0 0 15px 10px #00ff00 !important;
    }

    .square.capture-highlight {
      background: rgba(255, 0, 0, 0.3) !important;
      box-shadow: 0 0 15px 10px #ff0000 !important;
      animation: captureFlash 0.3s ease;
    }

    @keyframes captureFlash {
      0% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.1);
      }

      100% {
        transform: scale(1);
      }
    }

    /* Achievement display styles */
    .achievement-item {
      background: rgba(0, 255, 255, 0.1);
      border: 1px solid #00ffff80;
      border-radius: 3px;
      margin-bottom: 8px;
      padding: 5px;
      position: relative;
      display: flex;
      flex-direction: column;
    }

    .achievement-title {
      color: #00ffff;
      font-size: 0.5rem;
      font-weight: bold;
      text-shadow: 0 0 7px #00ffff;
    }

    .achievement-bonus {
      color: #ff00ff;
      font-size: 0.5rem;
      position: absolute;
      right: 5px;
      top: 5px;
    }

    .achievement-desc {
      color: #dddddd;
      font-size: 0.4rem;
      margin-top: 3px;
    }

    /* Score tracker styles */
    .score-tracker {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid #ff00ff;
      border-radius: 5px;
      padding: 5px 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 90;
      pointer-events: none;
      box-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
    }

    .score-value {
      color: #ff00ff;
      font-size: 1rem;
      text-shadow: 0 0 5px #ff00ff;
    }

    .score-notification {
      font-family: monospace;
      color: #00ffff;
      text-shadow: none;
      font-size: 0.65rem;
      font-weight: bold;
      line-height: normal;
      letter-spacing: 0.1em;
      text-align: center;
    }

    @keyframes fadeUp {
      from {
        opacity: 1;
        transform: translateY(0);
      }

      to {
        opacity: 0;
        transform: translateY(-10px);
      }
    }

    /* Difficulty selector */
    .difficulty-selector {
      display: flex;
      flex-direction: column;
      gap: 5px;
      margin-top: 10px;
    }

    .difficulty-option {
      display: flex;
      align-items: center;
      font-size: 0.45rem;
      padding: 3px;
      border: 1px solid #444;
      border-radius: 3px;
    }

    .difficulty-option.active {
      border-color: #00ffff;
      background: rgba(0, 255, 255, 0.1);
    }

    .difficulty-option input {
      margin-right: 5px;
    }

    .difficulty-name {
      flex: 1;
    }

    .difficulty-multi {
      color: #ff00ff;
    }
  </style>
</head>

<body>
  <div class="arcade">
    <div class="title">CH3SS</div>
    <div class="game-area">
      <div id="board" class="board"></div>
      <div class="info-container">
        <!-- Row 1: Player - Status -->
        <div class="info-row">
          <div class="info-panel">
            <div class="display">
              <div class="display-header">PLAYER</div>
              <div id="current-player" class="display-content">WHITE</div>
            </div>
          </div>
          <div class="info-panel">
            <div class="display">
              <div class="display-header">STATUS</div>
              <div id="game-status" class="display-content">PLAYING vs AI</div>
            </div>
          </div>
        </div>

        <!-- Row 2: White Captured - Black Captured -->
        <div class="info-row">
          <div class="info-panel">
            <div class="display">
              <div class="display-header">WHITE ADVANTAGE</div>
              <div class="display-content captured-display">
                <div id="white-captured" class="captured-pieces white-piece"></div>
                <div id="white-score" class="score-display score-white">+0</div>
              </div>
            </div>
          </div>
          <div class="info-panel">
            <div class="display">
              <div class="display-header">BLACK ADVANTAGE</div>
              <div class="display-content captured-display">
                <div id="black-captured" class="captured-pieces black-piece"></div>
                <div id="black-score" class="score-display score-black">+0</div>
              </div>
            </div>
          </div>
        </div>

        <!-- Row 3: CyberChess - Menu -->
        <div class="info-row">
          <div class="info-panel">
            <div class="display">
              <div class="display-header">CAPTURES SCORE</div>
              <div class="display-content rules-content">
                <div id="current-game-score"
                  style="display: flex; flex-direction: row; align-items: center; justify-content: space-between">
                  <div class="score-value"
                    style="font-size: 1.2rem; color: #ff00ff; text-shadow: 0 0 5px #ff00ff; padding-left: 5px">
                    000
                  </div>
                  <div id="score-notification" class="score-notification" style="font-size: 0.65rem">
                    No Captures Yet
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="info-panel">
            <div class="display">
              <div class="display-header">MENU</div>
              <div class="display-content menu-content">
                <div style="display: flex; justify-content: space-between; width: 100%; margin: 2px 0 0 0">
                  <button id="pgn-button" class="menu-inline-button"
                    style="flex-grow: 1; margin-right: 5px; text-shadow: none" title="View PGN notation">
                    <span id="last-pgn-moves" style="font-family: monospace; font-size: 0.7rem">Last Moves</span>
                  </button>
                  <button id="menu-button" class="menu-inline-button" style="padding: 4px 8px" title="Options">
                    <span style="font-size: 0.7rem">⚙️</span>
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Welcome Screen Overlay -->
  <div id="welcome-overlay" class="modal-overlay active">
    <div class="modal welcome-modal" style="max-width: 380px">
      <div class="modal-header" style="
                font-size: 0.8rem;
                color: #ffffff;
                font-weight: bold;
                text-shadow:
                  0 0 5px #00ffff,
                  0 0 10px #00ffff;
              ">
        Welcome, Ch3ss Mast3r
      </div>

      <div id="welcome-ai-options" class="modal-section" style="border-bottom: none">
        <div class="modal-content" style="text-align: left; font-size: 0.5rem; line-height: 1.6; margin-bottom: 10px">
          Read the scoring instructions below or jump right into battle!
        </div>

        <div class="option-buttons">
          <button id="welcome-color-black" class="option-button active">WHITE (YOU PLAY FIRST)</button>
          <button id="welcome-color-white" class="option-button">BLACK (AI PLAYS FIRST)</button>
        </div>

        <div class="modal-buttons" style="justify-content: center; margin-top: 25px">
          <button id="start-game" class="modal-button" style="font-size: 0.7rem; padding: 10px 20px">
            > START GAME < </button>
        </div>
      </div>

      <div class="modal-section">
        <div class="modal-content" style="text-align: left; font-size: 0.5rem; line-height: 1.6">
          Think beyond the checkmate.<br />
          Dominate the Farcade leaderboard strategically!
        </div>
      </div>

      <div class="modal-section" style="padding-bottom: 0px; margin-bottom: 0px; border-bottom: none">
        <div class="modal-section-title">// DATA PERSISTENCE //</div>
        <div id="welcome-score-persistence" class="modal-content" style="font-size: 0.5rem">
          <table style="width: 100%; border-collapse: collapse; margin: 10px 0">
            <tbody>
              <tr>
                <td>
                  Your score
                  <strong style="color: #ffffff; text-shadow: 0px 0px 6px #00ffff">accumulates across games</strong>
                  until you hit 'SUBMIT SCORE' and your total score is sent to Farcade for final analysis.
                </td>
              </tr>
            </tbody>
          </table>
        </div>

        <div class="modal-section-title">// CH3SS SCORE PROTOCOL //</div>
        <div id="welcome-score-protocol" class="modal-content" style="font-size: 0.5rem">
          <table style="width: 100%; border-collapse: collapse; margin: 10px 0">
            <tbody>
              <tr>
                <td strong style="color: #00ffff">» CORE DIRECTIVES</td>
              </tr>
              <tr>
                <td>Checkmate</td>
                <td style="text-align: right">+100</td>
              </tr>
              <tr>
                <td>Stalemate/Draw</td>
                <td style="text-align: right">+30</td>
              </tr>
            </tbody>
          </table>

          <table style="width: 100%; border-collapse: collapse; margin: 10px 0">
            <tbody>
              <tr>
                <td strong style="color: #00ffff">» ENEMY TARGETS</td>
              </tr>
              <tr>
                <td>Pawn</td>
                <td style="text-align: right">+2</td>
              </tr>
              <tr>
                <td>Knight/Bishop</td>
                <td style="text-align: right">+6</td>
              </tr>
              <tr>
                <td>Rook</td>
                <td style="text-align: right">+10</td>
              </tr>
              <tr>
                <td>Queen</td>
                <td style="text-align: right">+20</td>
              </tr>
            </tbody>
          </table>

          <table style="width: 100%; border-collapse: collapse; margin: 10px 0">
            <tbody>
              <tr>
                <td strong style="color: #00ffff">» SYSTEM OVERRIDES</td>
              </tr>
              <tr>
                <td>Win Streak Multiplier</td>
                <td style="text-align: right">+0.5x</td>
              </tr>
              <tr>
                <td>Blitz Win (under 20 moves)</td>
                <td style="text-align: right">+75</td>
              </tr>
              <tr>
                <td>Quick Win (under 5 minutes)</td>
                <td style="text-align: right">+50</td>
              </tr>
            </tbody>
          </table>
        </div>

        <div class="modal-section-title">// ACHIEVEMENTS //</div>
        <div id="welcome-achievements-list" class="modal-content">
          <div class="achievement-item">
            <span class="achievement-title">Queen Protector</span>
            <span class="achievement-bonus">+100</span>
            <div class="achievement-desc">Win without losing your Queen</div>
          </div>
          <div class="achievement-item">
            <span class="achievement-title">Pawn Slayer</span>
            <span class="achievement-bonus">+150</span>
            <div class="achievement-desc">Deliver checkmate using a Pawn</div>
          </div>
          <div class="achievement-item">
            <span class="achievement-title">Speed Demon</span>
            <span class="achievement-bonus">+200</span>
            <div class="achievement-desc">Win 5 games within 30 moves</div>
          </div>
          <div class="achievement-item">
            <span class="achievement-title">Unstoppable</span>
            <span class="achievement-bonus">+500</span>
            <div class="achievement-desc">Win 10 consecutive games</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Game Menu Modal -->
  <div id="menu-modal" class="modal-overlay">
    <div class="modal">
      <div class="modal-header">
        CH3SS MENU
        <button id="close-modal" class="modal-close-button">×</button>
      </div>

      <div class="modal-section">
        <div class="modal-section-title">GAME OPTIONS</div>
        <div class="modal-content">
          <div class="option-group">
            <div class="option-label">GAME MODE:</div>
            <div class="option-buttons">
              <button id="mode-human" class="option-button active">HUMAN VS HUMAN (IN-PERSON)</button>
              <button id="mode-ai" class="option-button">HUMAN VS AI</button>
            </div>
          </div>

          <div id="ai-options" class="option-group" style="display: none">
            <div class="option-label">PLAY AS:</div>
            <div class="option-buttons">
              <button id="ai-color-black" class="option-button active">WHITE (YOU PLAY FIRST)</button>
              <button id="ai-color-white" class="option-button">BLACK (AI PLAYS FIRST)</button>
            </div>

            <div class="option-label" style="margin-top: 10px">DIFFICULTY:</div>
            <div class="difficulty-selector" style="opacity: 0.5; position: relative">
              <div style="
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: rgba(0, 0, 0, 0.7);
                        padding: 5px 10px;
                        border: 1px solid #00ffff;
                        color: #00ffff;
                        font-size: 0.5rem;
                        z-index: 1;
                      ">
                COMING SOON
              </div>
              <label class="difficulty-option" for="diff-easy">
                <input type="radio" id="diff-easy" name="ai-difficulty" value="easy" disabled />
                <span class="difficulty-name">Easy</span>
                <span class="difficulty-multi">x1.0</span>
              </label>
              <label class="difficulty-option active" for="diff-medium">
                <input type="radio" id="diff-medium" name="ai-difficulty" value="medium" checked disabled />
                <span class="difficulty-name">Medium</span>
                <span class="difficulty-multi">x1.0</span>
              </label>
              <label class="difficulty-option" for="diff-hard">
                <input type="radio" id="diff-hard" name="ai-difficulty" value="hard" disabled />
                <span class="difficulty-name">Hard</span>
                <span class="difficulty-multi">x1.0</span>
              </label>
              <label class="difficulty-option" for="diff-expert">
                <input type="radio" id="diff-expert" name="ai-difficulty" value="expert" disabled />
                <span class="difficulty-name">Expert</span>
                <span class="difficulty-multi">x1.0</span>
              </label>
            </div>
          </div>
          <div class="spacer-small"></div>
          <button id="new-game-modal" class="modal-button">NEW GAME</button>
        </div>
      </div>

      <div class="modal-section">
        <div class="modal-section-title">PLAYER DATA</div>
        <div class="modal-content">
          <div class="option-group">
            <div class="option-buttons">
              <button id="view-stats-button" class="option-button">VIEW STATS</button>
              <button id="reset-stats-button" class="option-button danger">RESET ALL STATS</button>
            </div>
          </div>
        </div>
      </div>

      <div class="modal-section">
        <div class="modal-section-title">GAME RULES</div>
        <div class="modal-content">
          Standard chess rules apply in a cyberpunk setting:<br /><br />
          • Each piece has a unique movement pattern<br />
          • Pawns move forward one square, capture diagonally<br />
          • Knights move in an L-shape, can jump over pieces<br />
          • Bishops move diagonally any number of squares<br />
          • Rooks move horizontally or vertically<br />
          • Queens combine bishop and rook moves<br />
          • Kings move one square in any direction<br />
          • Checkmate happens when the king is threatened with capture and can't escape
        </div>
      </div>

      <div class="modal-section">
        <div class="modal-section-title">SPECIAL MOVES</div>
        <div class="modal-content">
          • Castling: King moves two squares toward a rook, and the rook moves to the other side of the king<br />
          • En Passant: Pawns can capture an opponent's pawn that has moved two squares forward in one move<br />
          • Pawn Promotion: When a pawn reaches the opposite end of the board, it can be promoted to any other piece
        </div>
      </div>

      <div class="modal-section">
        <div class="modal-section-title">PIECE VALUES</div>
        <div class="modal-content">
          • Pawn: 1 point<br />
          • Knight: 3 points<br />
          • Bishop: 3 points<br />
          • Rook: 5 points<br />
          • Queen: 9 points<br />
          • King: Infinite (game lost if checkmate)
        </div>
      </div>
    </div>
  </div>

  <!-- PGN Modal -->
  <div id="pgn-modal" class="modal-overlay">
    <div class="modal" style="max-width: 350px">
      <div class="modal-header">GAME NOTATION</div>

      <div class="modal-section">
        <div class="modal-section-title">PGN</div>
        <div class="modal-content">
          <div id="full-pgn-output" style="
                    font-family: monospace;
                    font-size: 0.75rem;
                    color: #00ffff;
                    white-space: pre-wrap;
                    max-height: 200px;
                    overflow-y: auto;
                    text-align: left;
                    font-family: monospace;
                    padding: 5px;
                    background: rgba(0, 0, 0, 0.3);
                  "></div>
        </div>
      </div>

      <div class="modal-buttons">
        <button id="close-pgn-modal" class="modal-button">CLOSE</button>
      </div>
    </div>
  </div>

  <!-- Scoring System Overlay -->
  <div id="scoring-overlay" class="modal-overlay">
    <div class="modal" style="max-width: 380px; max-height: 90vh">
      <div class="modal-header">CH3SS SCOREBOARD</div>

      <div class="modal-section">
        <div class="modal-section-title">YOUR SCORE</div>
        <div id="final-score-display" class="modal-content"
          style="text-align: center; font-size: 1.5rem; color: #ff00ff; margin: 10px 0; text-shadow: 0 0 10px #ff00ff">
          437
        </div>
        <div id="score-breakdown" class="modal-content" style="font-size: 0.5rem">
          <table style="width: 100%; border-collapse: collapse; margin: 10px 0">
            <tr>
              <td>Base (Win)</td>
              <td style="text-align: right">+100</td>
            </tr>
            <tr>
              <td>Quick Win (Less than 5 min)</td>
              <td style="text-align: right">+50</td>
            </tr>
            <tr>
              <td>Captures (Pawn x3, Bishop x1, Rook x2, Queen x1)</td>
              <td style="text-align: right">+52</td>
            </tr>
            <tr>
              <td>Win Streak Bonus (x1.2)</td>
              <td style="text-align: right">x1.2</td>
            </tr>
            <tr style="
                      border-top: 1px solid #ff00ff80;
                      margin-top: 5px;
                      padding-top: 5px;
                      color: #ff00ff;
                      font-weight: bold;
                    ">
              <td>TOTAL SCORE</td>
              <td style="text-align: right">437</td>
            </tr>
          </table>
        </div>
      </div>

      <div class="modal-section">
        <div class="modal-section-title">ACHIEVEMENTS</div>
        <div id="achievements-list" class="modal-content">
          <div class="achievement-item">
            <span class="achievement-title">Speed Demon</span>
            <span class="achievement-bonus">+200</span>
            <div class="achievement-desc">Win 5 games within 30 moves</div>
          </div>
        </div>
      </div>

      <div class="modal-section">
        <div class="modal-section-title">STATS</div>
        <div id="player-stats" class="modal-content">
          <table style="width: 100%; border-collapse: collapse; font-size: 0.45rem">
            <tr>
              <td>Games Played</td>
              <td style="text-align: right">12</td>
            </tr>
            <tr>
              <td>Wins / Draws / Losses</td>
              <td style="text-align: right">8 / 3 / 1</td>
            </tr>
            <tr>
              <td>Current Win Streak</td>
              <td style="text-align: right">3</td>
            </tr>
            <tr>
              <td>Highest Win Streak</td>
              <td style="text-align: right">5</td>
            </tr>
            <tr>
              <td>Total Score</td>
              <td style="text-align: right">2,534</td>
            </tr>
          </table>
        </div>
      </div>

      <div class="modal-buttons">
        <button id="keep-playing-scoring" class="modal-button">KEEP PLAYING</button>
        <!-- Renamed from close-scoring -->
        <button id="submit-final-score" class="modal-button">SUBMIT SCORE</button>
        <!-- Removed Share Button -->
      </div>
    </div>
  </div>

  <!-- Real-time Score Display -->
  <div id="current-score-display" class="score-tracker" style="display: none">
    <div class="score-value">0</div>
    <div id="score-notification" class="score-notification"></div>
  </div>

  <script>
    // Wrap main game logic in a scope to avoid polluting global namespace
    (function () {
      // Chess Game Logic using chess.js (available globally from the initial script tag)
      // Create a new chess instance for the main thread
      let chess = new Chess();

      // Unicode mapping for chess pieces
      const pieceMapping = {
        k: "♚",
        q: "♛",
        r: "♖",
        b: "♗",
        n: "♞",
        p: "♙",
        K: "♚",
        Q: "♛",
        R: "♖",
        B: "♗",
        N: "♞",
        P: "♙",
      };

      // Game state variables
      let selectedPiece = null;
      let validMoves = [];
      let lastMove = {from: null, to: null};

      // Audio for piece interactions
      const piecePutDownSound = new Audio(
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/robIosgxHOhq/up-lVnF69uvGB7LxfHd4xQNXPvjHNuhzm.wav",
      );
      const piecePickUpSound = new Audio(
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/robIosgxHOhq/down-3NEqSVwCnAIyxHw3rEt0K7xdUrLW6i.wav",
      );
      const pieceCaptureSound = new Audio(
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/robIosgxHOhq/pieceCapture-tkzgPSppuXLlK9vkkFLBz0oXfDF2u1.wav",
      );
      const buttonClickSound = new Audio(
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/robIosgxHOhq/click-ZXjx3PMJuBv8DxfUFuTzQrQpYi2fwL.wav",
      );
      // Preload audio
      piecePutDownSound.load();
      piecePickUpSound.load();
      pieceCaptureSound.load();
      buttonClickSound.load();

      // Farcade SDK variables
      let isMuted = false;

      // AI variables
      let gameMode = "ai"; // default to AI
      let aiColor = "black"; // default AI plays black
      let aiThinking = false;
      let aiDifficulty = "medium"; // Placeholder
      let aiWorker = null; // Variable to hold the AI worker instance

      // Scoring system (kept in main thread for now)
      let gameScore = 0;
      let scoringSystem = {
        base: {win: 100, draw: 30, loss: 10},
        quickPlay: {movesUnder20: 75, movesUnder30: 30, timeUnder5Min: 50},
        captures: {p: 2, n: 6, b: 6, r: 10, q: 20},
        difficultyMultiplier: {easy: 1.0, medium: 1.5, hard: 2.0, expert: 3.0},
        achievements: {
          unstoppable: {title: "Unstoppable", bonus: 250, description: "Win 10 consecutive games"},
          queenProtector: {title: "Queen Protector", bonus: 100, description: "Win without losing your Queen"},
          pawnSlayer: {title: "Pawn Slayer", bonus: 150, description: "Deliver checkmate using a Pawn"},
          speedDemon: {title: "Speed Demon", bonus: 200, description: "Win 5 games within 30 moves"},
        },
        penalties: {earlyLoss: -15, timeout: -10},
      };

      // Player stats
      let playerStats = {
        gamesPlayed: 0,
        wins: 0,
        draws: 0,
        losses: 0,
        currentWinStreak: 0,
        highestWinStreak: 0,
        quickWinsUnder30Moves: 0,
        capturedPieces: {p: 0, n: 0, b: 0, r: 0, q: 0},
        capturedPieceValue: 0,
        totalScore: 0,
        achievements: [],
        startTime: null,
        consecutiveCaptures: 0,
        lastCaptureMove: -1,
        queenLost: false,
        checkmateWithPawn: false,
        moveHistory: [], // Should likely be PGN string or array of moves
      };

      // Track captured pieces
      let capturedPieces = {white: [], black: []};

      // DOM Elements
      const boardElement = document.getElementById("board");
      const currentPlayerElement = document.getElementById("current-player");
      const gameStatusElement = document.getElementById("game-status");
      const menuButton = document.getElementById("menu-button");
      const menuModal = document.getElementById("menu-modal");
      const newGameModalButton = document.getElementById("new-game-modal");
      const closeModalButton = document.getElementById("close-modal");
      const whiteCapturedElement = document.getElementById("white-captured");
      const blackCapturedElement = document.getElementById("black-captured");
      const whiteScoreElement = document.getElementById("white-score");
      const blackScoreElement = document.getElementById("black-score");
      const modeHumanButton = document.getElementById("mode-human");
      const modeAIButton = document.getElementById("mode-ai");
      const aiOptionsContainer = document.getElementById("ai-options");
      const aiColorWhiteButton = document.getElementById("ai-color-white");
      const aiColorBlackButton = document.getElementById("ai-color-black");
      const welcomeOverlay = document.getElementById("welcome-overlay");
      const welcomeColorWhiteButton = document.getElementById("welcome-color-white");
      const welcomeColorBlackButton = document.getElementById("welcome-color-black");
      const startGameButton = document.getElementById("start-game");
      const pgnButton = document.getElementById("pgn-button");
      const pgnModal = document.getElementById("pgn-modal");
      const fullPgnOutput = document.getElementById("full-pgn-output");
      const lastPgnMoves = document.getElementById("last-pgn-moves");
      const closePgnModal = document.getElementById("close-pgn-modal");
      const backgroundMusic = document.getElementById("background-music");

      // --- Helper Functions (Mostly Unchanged) ---
      function playPieceSound() {
        /* ... unchanged ... */
        if (!isMuted && piecePutDownSound) {
          piecePutDownSound.currentTime = 0;
          piecePutDownSound.play().catch((error) => console.log("Audio playback error:", error));
        }
      }
      function playPutDownSound() {
        /* ... unchanged ... */
        if (!isMuted && piecePickUpSound) {
          piecePickUpSound.currentTime = 0;
          piecePickUpSound.play().catch((error) => console.log("Audio playback error:", error));
        }
      }
      function playButtonClickSound() {
        /* ... unchanged ... */
        if (!isMuted && buttonClickSound) {
          buttonClickSound.currentTime = 0;
          buttonClickSound.play().catch((error) => console.log("Button click sound playback error:", error));
        }
      }
      function getPieceColor(piece) {
        /* ... unchanged ... */
        if (!piece) return null;
        return piece === piece.toUpperCase() ? "white" : "black";
      }
      function getPieceNotation(piece) {
        /* ... unchanged ... */
        if (!piece) return null;
        return piece.color === "w" ? piece.type.toUpperCase() : piece.type.toLowerCase();
      }
      function squareToCoords(square) {
        /* ... unchanged ... */
        const col = square.charCodeAt(0) - "a".charCodeAt(0);
        const row = 8 - parseInt(square.charAt(1));
        return [row, col];
      }
      function coordsToSquare(row, col) {
        /* ... unchanged ... */
        const file = String.fromCharCode("a".charCodeAt(0) + col);
        const rank = 8 - row;
        return file + rank;
      }
      function debugLog(message, data = null) {
        /* ... unchanged ... */
        const timestamp = new Date().toISOString().split("T")[1].split(".")[0];
        console.log(`[${timestamp}] ${message}`, data ? data : "");
      }
      function convertChessJsBoard() {
        /* ... unchanged ... */
        const board = chess.board();
        const convertedBoard = Array(8)
          .fill()
          .map(() => Array(8).fill(null));
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            const piece = board[row][col];
            if (piece) {
              convertedBoard[row][col] = piece.color === "w" ? piece.type.toUpperCase() : piece.type.toLowerCase();
            }
          }
        }
        return convertedBoard;
      }
      function getValidMovesForSquare(row, col) {
        /* ... unchanged ... */
        const square = coordsToSquare(row, col);
        const moves = chess.moves({square: square, verbose: true});
        return moves.map((move) => squareToCoords(move.to));
      }
      function updateCapturedPiecesFromMove(move) {
        /* ... unchanged ... */
        if (move.captured) {
          const capturedPiece = move.color === "w" ? move.captured.toLowerCase() : move.captured.toUpperCase();
          if (move.color === "w") {
            capturedPieces.white.push(capturedPiece);
          } else {
            capturedPieces.black.push(capturedPiece);
          }
          const playerColor = aiColor === "black" ? "w" : "b";
          if (move.color === playerColor) {
            playerStats.capturedPieces[move.captured]++;
            const captureValue = scoringSystem.captures[move.captured];
            playerStats.capturedPieceValue += captureValue;
            const currentMoveNumber = chess.history().length;
            if (playerStats.lastCaptureMove === currentMoveNumber - 2) {
              playerStats.consecutiveCaptures++;
              const comboPoints = 5;
              playerStats.capturedPieceValue += comboPoints;
              showScoreNotification(`COMBO x${playerStats.consecutiveCaptures}`, comboPoints);
            } else {
              playerStats.consecutiveCaptures = 1;
            }
            playerStats.lastCaptureMove = currentMoveNumber;
            showScoreNotification(`Captured ${move.captured.toUpperCase()}`, captureValue);
          }
          if (move.captured === "q" && move.color !== playerColor) {
            playerStats.queenLost = true;
          }
        }
      }
      function calculateScoreDifference() {
        /* ... unchanged ... */
        const pieceValues = {p: 1, n: 3, b: 3, r: 5, q: 9, k: 0};
        let whiteScore = 0,
          blackScore = 0;
        capturedPieces.white.forEach((piece) => {
          whiteScore += pieceValues[piece.toLowerCase()];
        });
        capturedPieces.black.forEach((piece) => {
          blackScore += pieceValues[piece.toLowerCase()];
        });
        return {whiteScore, blackScore};
      }
      function updateCapturedPieces() {
        /* ... unchanged ... */
        whiteCapturedElement.innerHTML = "";
        blackCapturedElement.innerHTML = "";
        capturedPieces.white.forEach((piece) => {
          const pieceSpan = document.createElement("span");
          pieceSpan.textContent = pieceMapping[piece];
          pieceSpan.className = "black-piece";
          whiteCapturedElement.appendChild(pieceSpan);
        });
        capturedPieces.black.forEach((piece) => {
          const pieceSpan = document.createElement("span");
          pieceSpan.textContent = pieceMapping[piece];
          pieceSpan.className = "white-piece";
          blackCapturedElement.appendChild(pieceSpan);
        });
        const {whiteScore, blackScore} = calculateScoreDifference();
        if (whiteScore > blackScore) {
          whiteScoreElement.textContent = `+${whiteScore - blackScore}`;
          blackScoreElement.textContent = "+0";
        } else if (blackScore > whiteScore) {
          blackScoreElement.textContent = `+${blackScore - whiteScore}`;
          whiteScoreElement.textContent = "+0";
        } else {
          whiteScoreElement.textContent = "+0";
          blackScoreElement.textContent = "+0";
        }
      }
      function triggerHapticFeedback() {
        /* ... unchanged ... */
        if (window.FarcadeSDK && typeof window.FarcadeSDK.singlePlayer?.actions?.hapticFeedback === "function") {
          window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
        }
      }
      function updateFarcadeScore() {
        /* ... unchanged ... */
        if (window.FarcadeSDK) {
          window.FarcadeSDK.singlePlayer.actions.gameOver({score: playerStats.totalScore});
          console.log(`Submitted score to Farcade: ${playerStats.totalScore}`);
        }
      }
      function startGameTimer() {
              /* ... unchanged ... */ playerStats.startTime = Date.now();
      }
      function getGameTimeInMinutes() {
        /* ... unchanged ... */
        if (!playerStats.startTime) return 0;
        return (Date.now() - playerStats.startTime) / (1000 * 60);
      }
      function showScoreNotification(text, points) {
        /* ... unchanged ... */
        const scoreValueElements = document.querySelectorAll(".score-value");
        const scoreNotifications = document.querySelectorAll(".score-notification");
        let currentScore = parseInt(scoreValueElements[0].textContent) || 0;
        currentScore += points;
        const formattedScore = currentScore.toString().padStart(3, "0");
        scoreValueElements.forEach((element) => {
          element.textContent = formattedScore;
        });
        const prefix = points > 0 ? "+" : "";
        scoreNotifications.forEach((notification) => {
          notification.textContent = `${text} ${prefix}${points}`;
          notification.style.color = points > 0 ? "#00ffff" : "#ff5050";
          notification.style.opacity = "1";
          setTimeout(() => {
            notification.style.transition = "color 1s, opacity 1s";
            notification.style.color = "";
            notification.style.opacity = "0.7";
          }, 1000);
          if (text.includes("COMBO")) {
            notification.style.fontSize = "0.65rem";
            notification.style.textShadow = "none";
          }
        });
      }
      function calculateGameScore(gameResult) {
        /* ... unchanged ... */
        let score = 0;
        let scoreBreakdown = [];
        let achievementsEarned = [];
        const totalMoves = chess.history().length;
        const timeSpent = getGameTimeInMinutes();
        if (gameMode !== "ai") return {score: 0, breakdown: [], achievements: []};
        if (gameResult === "win") {
          /* ... base points ... */
          score += scoringSystem.base.win;
          scoreBreakdown.push({description: "Base (Win)", points: scoringSystem.base.win});
          playerStats.wins++;
          playerStats.currentWinStreak++;
        } else if (gameResult === "draw") {
          /* ... base points ... */
          score += scoringSystem.base.draw;
          scoreBreakdown.push({description: "Base (Draw)", points: scoringSystem.base.draw});
          playerStats.draws++;
          playerStats.currentWinStreak = 0;
        } else {
          /* ... base points ... */
          score += scoringSystem.base.loss;
          scoreBreakdown.push({description: "Base (Loss)", points: scoringSystem.base.loss});
          playerStats.losses++;
          playerStats.currentWinStreak = 0;
          if (totalMoves < 15) {
            /* ... penalty ... */
            score += scoringSystem.penalties.earlyLoss;
            scoreBreakdown.push({description: "Early Loss Penalty", points: scoringSystem.penalties.earlyLoss});
          }
        }
        if (playerStats.currentWinStreak > playerStats.highestWinStreak)
          playerStats.highestWinStreak = playerStats.currentWinStreak;
        if (gameResult === "win") {
          /* ... quick play bonuses ... */
          if (totalMoves < 20) {
            score += scoringSystem.quickPlay.movesUnder20;
            scoreBreakdown.push({
              description: "Quick Win (under 20 moves)",
              points: scoringSystem.quickPlay.movesUnder20,
            });
            playerStats.quickWinsUnder30Moves++;
          } else if (totalMoves < 30) {
            score += scoringSystem.quickPlay.movesUnder30;
            scoreBreakdown.push({
              description: "Quick Win (under 30 moves)",
              points: scoringSystem.quickPlay.movesUnder30,
            });
            playerStats.quickWinsUnder30Moves++;
          }
          if (timeSpent < 5) {
            score += scoringSystem.quickPlay.timeUnder5Min;
            scoreBreakdown.push({
              description: "Quick Win (under 5 minutes)",
              points: scoringSystem.quickPlay.timeUnder5Min,
            });
          }
        }
        const capturePoints = playerStats.capturedPieceValue;
        if (capturePoints > 0) {
          /* ... capture rewards ... */
          score += capturePoints;
          const captureDesc = Object.entries(playerStats.capturedPieces)
            .filter(([pc, ct]) => ct > 0)
            .map(
              ([pc, ct]) =>
                ({p: "Pawn", n: "Knight", b: "Bishop", r: "Rook", q: "Queen"})[pc] + (ct > 1 ? ` x${ct}` : ""),
            )
            .join(", ");
          scoreBreakdown.push({description: `Captures (${captureDesc})`, points: capturePoints});
        }
        let streakMultiplier = 1;
        if (playerStats.currentWinStreak > 1) {
          /* ... streak multiplier ... */
          streakMultiplier = 1 + (playerStats.currentWinStreak - 1) * 0.5;
          scoreBreakdown.push({
            description: `${playerStats.currentWinStreak} Win Streak Bonus`,
            multiplier: streakMultiplier.toFixed(1),
          });
        }
        const baseScore = score;
        score = Math.round(baseScore * streakMultiplier);
        /* ... achievement checks ... */
        if (playerStats.currentWinStreak >= 10 && !playerStats.achievements.includes("unstoppable")) {
          playerStats.achievements.push("unstoppable");
          const a = scoringSystem.achievements.unstoppable;
          achievementsEarned.push({id: "unstoppable", ...a});
          score += a.bonus;
        }
        if (gameResult === "win" && !playerStats.queenLost && !playerStats.achievements.includes("queenProtector")) {
          playerStats.achievements.push("queenProtector");
          const a = scoringSystem.achievements.queenProtector;
          achievementsEarned.push({id: "queenProtector", ...a});
          score += a.bonus;
        }
        if (
          gameResult === "win" &&
          playerStats.checkmateWithPawn &&
          !playerStats.achievements.includes("pawnSlayer")
        ) {
          playerStats.achievements.push("pawnSlayer");
          const a = scoringSystem.achievements.pawnSlayer;
          achievementsEarned.push({id: "pawnSlayer", ...a});
          score += a.bonus;
        }
        if (playerStats.quickWinsUnder30Moves >= 5 && !playerStats.achievements.includes("speedDemon")) {
          playerStats.achievements.push("speedDemon");
          const a = scoringSystem.achievements.speedDemon;
          achievementsEarned.push({id: "speedDemon", ...a});
          score += a.bonus;
        }
        playerStats.totalScore += score;
        playerStats.gamesPlayed++;
        savePlayerStats();
        return {score, breakdown: scoreBreakdown, achievements: achievementsEarned};
      }
      function savePlayerStats() {
              /* ... unchanged ... */ console.log("Stats not saved (arcade mode)");
      }
      function loadPlayerStats() {
              /* ... unchanged ... */ console.log("Stats not loaded (arcade mode)");
      }
      function showScoringOverlay(scoreResult) {
        /* ... unchanged, uses calculateGameScore result ... */
        const scoringOverlay = document.getElementById("scoring-overlay");
        const finalScoreDisplay = document.getElementById("final-score-display");
        const scoreBreakdownEl = document.getElementById("score-breakdown");
        const achievementsList = document.getElementById("achievements-list");
        const playerStatsElement = document.getElementById("player-stats");
        finalScoreDisplay.textContent = scoreResult.score;
        let breakdownHtml = '<table style="width:100%; border-collapse:collapse; margin:10px 0;">';
        if (scoreResult.breakdown && scoreResult.breakdown.length > 0) {
          scoreResult.breakdown.forEach((item) => {
            if (item.multiplier) {
              breakdownHtml += `<tr><td>${item.description}</td><td style="text-align:right;">x${item.multiplier}</td></tr>`;
            } else {
              breakdownHtml += `<tr><td>${item.description}</td><td style="text-align:right;">${item.points >= 0 ? "+" : ""}${item.points}</td></tr>`;
            }
          });
        }
        breakdownHtml += `<tr style="border-top: 1px solid #ff00ff80; margin-top:5px; padding-top:5px; color:#ff00ff; font-weight:bold;"><td>TOTAL SCORE</td><td style="text-align:right;">${scoreResult.score}</td></tr></table>`;
        if (playerStats.currentWinStreak > 0) {
          breakdownHtml += `<div style="margin-top:15px; text-align:center; padding:8px; border:1px dashed #ff00ff; border-radius:5px; background:rgba(255,0,255,0.1);"><span style="color:#ff00ff; font-weight:bold;">WIN STREAK: ${playerStats.currentWinStreak}</span><br><span style="font-size:0.45rem; color:#00ffff;">Keep playing to increase your streak multiplier!<br>Each win makes the next one worth more points!</span></div>`;
        } else {
          breakdownHtml += `<div style="margin-top:15px; text-align:center; padding:8px; border:1px dashed #00ffff; border-radius:5px; background:rgba(0,255,255,0.1);"><span style="color:#00ffff; font-weight:bold;">SUBMIT YOUR SCORE</span><br><span style="font-size:0.45rem;">Submit your total score of ${playerStats.totalScore} points to the leaderboard!</span></div>`;
        }
        scoreBreakdownEl.innerHTML = breakdownHtml;
        if (scoreResult.achievements && scoreResult.achievements.length > 0) {
          let achievementsHtml = "";
          scoreResult.achievements.forEach((achievement) => {
            achievementsHtml += `<div class="achievement-item"><span class="achievement-title">${achievement.title}</span><span class="achievement-bonus">+${achievement.bonus}</span><div class="achievement-desc">${achievement.description}</div></div>`;
          });
          achievementsList.innerHTML = achievementsHtml;
        } else {
          achievementsList.innerHTML =
            '<div style="text-align:center; opacity:0.7; font-style:italic;">No new achievements</div>';
        }
        playerStatsElement.innerHTML = `<table style="width:100%; border-collapse:collapse; font-size:0.45rem;"><tr><td>Games Played</td><td style="text-align:right;">${playerStats.gamesPlayed}</td></tr><tr><td>Wins / Draws / Losses</td><td style="text-align:right;">${playerStats.wins} / ${playerStats.draws} / ${playerStats.losses}</td></tr><tr><td>Current Win Streak</td><td style="text-align:right;">${playerStats.currentWinStreak}</td></tr><tr><td>Highest Win Streak</td><td style="text-align:right;">${playerStats.highestWinStreak}</td></tr><tr><td>Total Score</td><td style="text-align:right;">${playerStats.totalScore.toLocaleString()}</td></tr></table>`;
        document.querySelector("#scoring-overlay .modal-header").textContent = "CH3SS PLAYER STATS";
        const closeButton = document.getElementById("keep-playing-scoring");
        const newCloseButton = closeButton.cloneNode(true);
        closeButton.parentNode.replaceChild(newCloseButton, closeButton);
        newCloseButton.addEventListener("click", () => {
          scoringOverlay.classList.remove("active");
          document.querySelector("#scoring-overlay .modal-header").textContent = "CH3SS SCOREBOARD";
        });
        scoringOverlay.classList.add("active");
      }
      function resetAllStats() {
        /* ... unchanged ... */
        playerStats = {
          gamesPlayed: 0,
          wins: 0,
          draws: 0,
          losses: 0,
          currentWinStreak: 0,
          highestWinStreak: 0,
          quickWinsUnder30Moves: 0,
          capturedPieces: {p: 0, n: 0, b: 0, r: 0, q: 0},
          capturedPieceValue: 0,
          totalScore: 0,
          achievements: [],
          startTime: Date.now(),
          consecutiveCaptures: 0,
          lastCaptureMove: -1,
          queenLost: false,
          checkmateWithPawn: false,
          moveHistory: [],
        };
        localStorage.removeItem("ch3ss_playerStats");
        const scoreValue = document.querySelector(".score-value");
        if (scoreValue) scoreValue.textContent = "0";
        alert("All player stats and achievements have been reset!");
        menuModal.classList.remove("active");
        resetGame();
      }
      function showStatsOverlay() {
        /* ... unchanged ... */
        const scoringOverlay = document.getElementById("scoring-overlay");
        const finalScoreDisplay = document.getElementById("final-score-display");
        const scoreBreakdownEl = document.getElementById("score-breakdown");
        const achievementsList = document.getElementById("achievements-list");
        const playerStatsElement = document.getElementById("player-stats");
        finalScoreDisplay.textContent = playerStats.totalScore;
        scoreBreakdownEl.innerHTML =
          '<div style="text-align:center; margin: 10px 0;">View your current CH3SS statistics below</div>';
        if (playerStats.achievements && playerStats.achievements.length > 0) {
          let achievementsHtml = "";
          playerStats.achievements.forEach((id) => {
            const a = scoringSystem.achievements[id];
            if (a) {
              achievementsHtml += `<div class="achievement-item"><span class="achievement-title">${a.title}</span><span class="achievement-bonus">+${a.bonus}</span><div class="achievement-desc">${a.description}</div></div>`;
            }
          });
          achievementsList.innerHTML = achievementsHtml;
        } else {
          achievementsList.innerHTML =
            '<div style="text-align:center; opacity:0.7; font-style:italic;">No achievements yet</div>';
        }
        playerStatsElement.innerHTML = `<table style="width:100%; border-collapse:collapse; font-size:0.45rem;"><tr><td>Games Played</td><td style="text-align:right;">${playerStats.gamesPlayed}</td></tr><tr><td>Wins / Draws / Losses</td><td style="text-align:right;">${playerStats.wins} / ${playerStats.draws} / ${playerStats.losses}</td></tr><tr><td>Win Rate</td><td style="text-align:right;">${playerStats.gamesPlayed > 0 ? Math.round((playerStats.wins / playerStats.gamesPlayed) * 100) : 0}%</td></tr><tr><td>Current Win Streak</td><td style="text-align:right;">${playerStats.currentWinStreak}</td></tr><tr><td>Highest Win Streak</td><td style="text-align:right;">${playerStats.highestWinStreak}</td></tr><tr><td>Total Score</td><td style="text-align:right;">${playerStats.totalScore.toLocaleString()}</td></tr></table>`;
        document.querySelector("#scoring-overlay .modal-header").textContent = "CH3SS PLAYER STATS";
        const closeButton = document.getElementById("keep-playing-scoring");
        const newCloseButton = closeButton.cloneNode(true);
        closeButton.parentNode.replaceChild(newCloseButton, closeButton);
        newCloseButton.addEventListener("click", () => {
          scoringOverlay.classList.remove("active");
          document.querySelector("#scoring-overlay .modal-header").textContent = "CH3SS SCOREBOARD";
        });
        scoringOverlay.classList.add("active");
      }
      function updatePgnDisplay() {
        const history = chess.history();
        const fullPgn = chess.pgn();
        if (history.length > 0) {
          const lastMovesArr = history.slice(-3);
          lastPgnMoves.textContent = lastMovesArr.join(" ");
        } else {
          lastPgnMoves.textContent = "Last Moves";
        }
        fullPgnOutput.textContent = fullPgn || "No moves yet";
      }

      // --- Helper: Immediate Mate-In-One Detector ---
      function findMateInOne(chess) {
        const moves = chess.moves({verbose: true});
        for (let move of moves) {
          chess.move(move);
          if (chess.in_checkmate()) {
            chess.undo();
            return move;
          }
          chess.undo();
        }
        return null;
      }
      // --- End MIO Detect Helper ---

      function startBackgroundMusic() {
        if (!isMuted && backgroundMusic) {
          backgroundMusic.volume = 0.5;
          backgroundMusic.play().catch((error) => console.log("Background music playback error:", error));
        }
      }
      // --- End Helper Functions ---

      // --- Web Worker Setup ---
      let chessJsSource = "";

      // Define the code that will run inside the worker as a string
      const workerCode = `
    // Load chess.js inside the worker
    importScripts('https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js');
    if (typeof Chess === 'undefined') {
      console.error('[Worker] CRITICAL: chess.js failed to load');
      self.postMessage({ error: 'Chess library failed to load in worker' });
      self.close();
    }

    // --- Tiny Opening Book + Fisher–Yates Shuffle + FEN Normalizer ---
    const openingBook = {
      // 1. White’s 10 most popular first‑moves (White to move)
      "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w": [
        { from: "e2", to: "e4" },
        { from: "d2", to: "d4" },
        { from: "g1", to: "f3" },
        { from: "c2", to: "c4" },
        { from: "g2", to: "g3" },
        { from: "b1", to: "c3" },
        { from: "b2", to: "b3" },
        { from: "f2", to: "f4" },
        { from: "e2", to: "e3" },
        { from: "d2", to: "d3" }
      ],

      // Black replies to 1.e4
      "rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b": [
        { from: "e7", to: "e5" },
        { from: "c7", to: "c5" },
        { from: "e7", to: "e6" },
        { from: "g8", to: "f6" }
      ],

      // Black replies to 1.d4
      "rnbqkbnr/pppppppp/8/8/3P4/8/PPP1PPPP/RNBQKBNR b": [
        { from: "d7", to: "d5" },
        { from: "g8", to: "f6" },
        { from: "e7", to: "e6" },
        { from: "c7", to: "c6" }
      ],

      // Black replies to 1.Nf3
      "rnbqkbnr/pppppppp/8/8/8/5N2/PPPPPPPP/RNBQKB1R b": [
        { from: "g8", to: "f6" },
        { from: "d7", to: "d5" },
        { from: "e7", to: "e6" },
        { from: "c7", to: "c5" }
      ],

      // Black replies to 1.c4
      "rnbqkbnr/pppppppp/8/8/2P5/8/PP1PPPPP/RNBQKBNR b": [
        { from: "e7", to: "e5" },
        { from: "c7", to: "c5" },
        { from: "g8", to: "f6" },
        { from: "e7", to: "e6" }
      ],

      // Black replies to 1.g3
      "rnbqkbnr/pppppppp/8/8/8/6P1/PPPPPP1P/RNBQKBNR b": [
        { from: "e7", to: "e5" },
        { from: "g8", to: "f6" },
        { from: "d7", to: "d5" },
        { from: "e7", to: "e6" }
      ],

      // Black replies to 1.Nc3
      "rnbqkbnr/pppppppp/8/8/8/2N5/PPPPPPPP/R1BQKBNR b": [
        { from: "g8", to: "f6" },
        { from: "d7", to: "d5" },
        { from: "e7", to: "e6" },
        { from: "c7", to: "c5" }
      ],

      // Black replies to 1.b3
      "rnbqkbnr/pppppppp/8/8/1P6/8/P1PPPPPP/RNBQKBNR b": [
        { from: "e7", to: "e5" },
        { from: "d7", to: "d5" },
        { from: "g8", to: "f6" },
        { from: "e7", to: "e6" }
      ],

      // Black replies to 1.f4
      "rnbqkbnr/pppppppp/8/8/5P2/8/PPPPP1PP/RNBQKBNR b": [
        { from: "e7", to: "e5" },
        { from: "g8", to: "f6" },
        { from: "d7", to: "d5" },
        { from: "e7", to: "e6" }
      ],

      // Black replies to 1.e3
      "rnbqkbnr/pppppppp/8/8/8/4P3/PPPP1PPP/RNBQKBNR b": [
        { from: "e7", to: "e5" },
        { from: "c7", to: "c5" },
        { from: "d7", to: "d5" },
        { from: "g8", to: "f6" }
      ],

      // Black replies to 1.d3
      "rnbqkbnr/pppppppp/8/8/8/3P4/PPPP1PPP/RNBQKBNR b": [
        { from: "d7", to: "d5" },
        { from: "g8", to: "f6" },
        { from: "e7", to: "e6" },
        { from: "c7", to: "c6" }
      ],

    // Punish single‑pawn blunder 1.g4 with …e6
    "rnbqkbnr/pppppppp/8/8/6P1/8/PPPPPP1P/RNBQKBNR b": [
      { from: "e7", to: "e6" }
    ],

    // Punish single‑pawn blunder 1.f3 with …e6
    "rnbqkbnr/pppppppp/8/8/8/5P2/PPPPP1PP/RNBQKBNR b": [
      { from: "e7", to: "e6" }
    ],

    // 2. Fool’s Mate (after f3+g4 or g4+f3, Black has played e6 already; Black to move)
      "rnbqkbnr/pppp1ppp/4p3/8/6P1/5P2/PPPP1PPP/RNBQKBNR b": [
        { from: "d8", to: "h4" }  // …Qh4#
      ],

      // 3. Scholar’s Mate pre‑mate position (Black to move)
      "rnbqkbnr/pppp1ppp/2n2n2/4pQ2/2B1P3/8/PPPP1PPP/RNB1K1NR b": [
        { from: "d8", to: "h4" }
      ],

      // 4. Blackburne–Shilling Trap pre‑mate (Black to move)
      "r1bqkbnr/pppp1ppp/8/4Q3/3nB3/8/PPPP1PPP/RNB1K1NR b": [
        { from: "g5", to: "e5" }
      ],

      // 5. Legal’s Mate pre‑mate (Black to move)
      "r1bqk1nr/pppp1ppp/3p4/4N3/2B1b3/4P3/PPPP1PPP/RNBQK2R b": [
        { from: "d7", to: "d5" }
      ]
    };

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    // Strip full FEN down to exactly "piece‑placement + side‑to‑move"
    function normalizeFen(fen) {
      const parts = fen.split(' ');
      return parts[0] + ' ' + parts[1];
    }
    // --- end opening book/shuffle/normalizer ---

    // MVV/LVA + Killer Moves
    const PIECE_VALUE = { p: 1, n: 3, b: 3, r: 5, q: 9 };

    // Assign capture scores: (victim*10 − attacker)
    function scoreCapture(move) {
      if (!move.captured) return 0;
      const victim   = PIECE_VALUE[move.captured.toLowerCase()] || 0;
      const attacker = PIECE_VALUE[move.piece.toLowerCase()]    || 0;
      return (victim * 10) - attacker;
    }

    // Compare two moves for exact match
    function sameMove(a, b) {
      return b &&
             a.from === b.from &&
             a.to   === b.to &&
             a.promotion === b.promotion;
    }

    // Two “killer” slots per depth
    const MAX_DEPTH   = 4;  // should exceed your search ply
    const killerMoves = Array.from({ length: MAX_DEPTH }, () => [null, null]);

    // Order moves: captures first (MVV/LVA), then killer moves, then the rest
    function orderMoves(moves, depth) {
      const [k1, k2] = killerMoves[depth] || [null, null];
      return moves.sort((a, b) => {
        const ca = scoreCapture(a), cb = scoreCapture(b);
        if (ca || cb) return cb - ca;       // non‑zero capture scores first
        if (sameMove(a, k1)) return -1;     // killer #1
        if (sameMove(b, k1)) return  1;
        if (sameMove(a, k2)) return -1;     // killer #2
        if (sameMove(b, k2)) return  1;
        return 0;                           // otherwise original order
      });
    }

    // --- AI Logic from Example (Adapted) ---

    // Reverse a table for Black’s side
    var reverseArray = array => JSON.parse(JSON.stringify(array)).reverse();

    // --- Piece‑Square Tables ---
    var pawnEvalWhite = [
      [0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0],
      [5.0,  5.0,  5.0,  5.0,  5.0,  5.0,  5.0,  5.0],
      [1.0,  1.0,  2.0,  3.0,  3.0,  2.0,  1.0,  1.0],
      [0.5,  0.5,  1.0,  2.5,  2.5,  1.0,  0.5,  0.5],
      [0.0,  0.0,  0.0,  2.0,  2.0,  0.0,  0.0,  0.0],
      [0.5, -0.5, -1.0,  0.0,  0.0, -1.0, -0.5,  0.5],
      [0.5,  1.0,  1.0, -2.0, -2.0,  1.0,  1.0,  0.5],
      [0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0]
    ];
    var pawnEvalBlack = reverseArray(pawnEvalWhite);

    var knightEval = [
      [-5.0, -4.0, -3.0, -3.0, -3.0, -3.0, -4.0, -5.0],
      [-4.0, -2.0,  0.0,  0.0,  0.0,  0.0, -2.0, -4.0],
      [-3.0,  0.0,  1.0,  1.5,  1.5,  1.0,  0.0, -3.0],
      [-3.0,  0.5,  1.5,  2.0,  2.0,  1.5,  0.5, -3.0],
      [-3.0,  0.0,  1.5,  2.0,  2.0,  1.5,  0.0, -3.0],
      [-3.0,  0.5,  1.0,  1.5,  1.5,  1.0,  0.5, -3.0],
      [-4.0, -2.0,  0.0,  0.5,  0.5,  0.0, -2.0, -4.0],
      [-5.0, -4.0, -3.0, -3.0, -3.0, -3.0, -4.0, -5.0]
    ];

    var bishopEvalWhite = [
      [-2.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -2.0],
      [-1.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, -1.0],
      [-1.0,  0.0,  0.5,  1.0,  1.0,  0.5,  0.0, -1.0],
      [-1.0,  0.5,  0.5,  1.0,  1.0,  0.5,  0.5, -1.0],
      [-1.0,  0.0,  1.0,  1.0,  1.0,  1.0,  0.0, -1.0],
      [-1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0, -1.0],
      [-1.0,  0.5,  0.0,  0.0,  0.0,  0.0,  0.5, -1.0],
      [-2.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -2.0]
    ];
    var bishopEvalBlack = reverseArray(bishopEvalWhite);

    var rookEvalWhite = [
      [  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0],
      [  0.5,  1.0,  1.0,  1.0,  1.0,  1.0,  1.0,  0.5],
      [ -0.5,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, -0.5],
      [ -0.5,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, -0.5],
      [ -0.5,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, -0.5],
      [ -0.5,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, -0.5],
      [ -0.5,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, -0.5],
      [  0.0,  0.0,  0.0,  0.5,  0.5,  0.0,  0.0,  0.0]
    ];
    var rookEvalBlack = reverseArray(rookEvalWhite);

    var evalQueen = [
      [ -2.0, -1.0, -1.0, -0.5, -0.5, -1.0, -1.0, -2.0],
      [ -1.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0, -1.0],
      [ -1.0,  0.0,  0.5,  0.5,  0.5,  0.5,  0.0, -1.0],
      [ -0.5,  0.0,  0.5,  0.5,  0.5,  0.5,  0.0, -0.5],
      [  0.0,  0.0,  0.5,  0.5,  0.5,  0.5,  0.0, -0.5],
      [ -1.0,  0.5,  0.5,  0.5,  0.5,  0.5,  0.0, -1.0],
      [ -1.0,  0.0,  0.5,  0.0,  0.0,  0.0,  0.0, -1.0],
      [ -2.0, -1.0, -1.0, -0.5, -0.5, -1.0, -1.0, -2.0]
    ];

    var kingEvalWhite = [
      [ -3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0],
      [ -3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0],
      [ -3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0],
      [ -3.0, -4.0, -4.0, -5.0, -5.0, -4.0, -4.0, -3.0],
      [ -2.0, -3.0, -3.0, -4.0, -4.0, -3.0, -3.0, -2.0],
      [ -1.0, -2.0, -2.0, -2.0, -2.0, -2.0, -2.0, -1.0],
      [  2.0,  2.0,  0.0,  0.0,  0.0,  0.0,  2.0,  2.0],
      [  2.0,  3.0,  1.0,  0.0,  0.0,  1.0,  3.0,  2.0]
    ];
    var kingEvalBlack = reverseArray(kingEvalWhite);

    // Absolute piece value (no sign)
    var getPieceValue = function(piece, x, y) {
      if (!piece) return 0;
      var isWhite = piece.color === 'w';
      var t = piece.type;
      if (t === 'p') return 10 + (isWhite ? pawnEvalWhite[y][x] : pawnEvalBlack[y][x]);
      if (t === 'r') return 50 + (isWhite ? rookEvalWhite[y][x] : rookEvalBlack[y][x]);
      if (t === 'n') return 30 + knightEval[y][x];
      if (t === 'b') return 30 + (isWhite ? bishopEvalWhite[y][x] : bishopEvalBlack[y][x]);
      if (t === 'q') return 90 + evalQueen[y][x];
      if (t === 'k') return 9000 + (isWhite ? kingEvalWhite[y][x] : kingEvalBlack[y][x]);
      return 0;
    };

    // Material + positional eval from White’s POV
    var evaluateBoard = function(board) {
      var total = 0;
      for (var y = 0; y < 8; y++) {
        for (var x = 0; x < 8; x++) {
          var p = board[y][x];
          if (p) {
            var v = getPieceValue(p, x, y);
            total += p.color === 'w' ? v : -v;
          }
        }
      }
      return total;
    };

    // Minimax w/ αβ and killer‑move updates
    var minimax = function(depth, chessInstance, alpha, beta, isMaximisingPlayer) {
      if (depth === 0 || chessInstance.game_over()) {
        if (chessInstance.in_checkmate()) {
          return isMaximisingPlayer ? -Infinity : Infinity;
        }
        if (chessInstance.in_stalemate() || chessInstance.in_draw()) {
          return 0;
        }
        return evaluateBoard(chessInstance.board());
      }

      const moves = orderMoves(chessInstance.moves({ verbose: true }), depth);
      if (isMaximisingPlayer) {
        let best = -Infinity;
        for (let m of moves) {
          chessInstance.move(m);
          const score = minimax(depth - 1, chessInstance, alpha, beta, false);
          chessInstance.undo();

          if (score > best) best = score;
          alpha = Math.max(alpha, best);

          if (beta <= alpha) {
            if (!m.captured) {
              killerMoves[depth][1] = killerMoves[depth][0];
              killerMoves[depth][0] = m;
            }
            break;
          }
        }
        return best;
      } else {
        let best = Infinity;
        for (let m of moves) {
          chessInstance.move(m);
          const score = minimax(depth - 1, chessInstance, alpha, beta, true);
          chessInstance.undo();

          if (score < best) best = score;
          beta = Math.min(beta, best);

          if (beta <= alpha) {
            if (!m.captured) {
              killerMoves[depth][1] = killerMoves[depth][0];
              killerMoves[depth][0] = m;
            }
            break;
          }
        }
        return best;
      }
    };

    // Entry point
    var minimaxRoot = function(depth, fen, aiWorkerColor) {
      const chessInstance = new Chess(fen);
      const isWhite       = aiWorkerColor === 'white';
      const moves         = orderMoves(chessInstance.moves({ verbose: true }), depth);
      let bestValue       = isWhite ? -Infinity : Infinity;
      let bestMove        = null;

      for (let m of moves) {
        chessInstance.move(m);
        const val = minimax(depth - 1, chessInstance, -Infinity, Infinity, !isWhite);
        chessInstance.undo();

        if ((isWhite && val >= bestValue) || (!isWhite && val <= bestValue)) {
          bestValue = val;
          bestMove  = m;
        }
      }

      console.log('[Worker] Best move found:', bestMove?.san, 'eval:', bestValue);
      return bestMove
        ? { from: bestMove.from, to: bestMove.to, promotion: bestMove.promotion }
        : null;
    };

    // --- Message handler with opening‑book check ---
    self.onmessage = function(event) {
      const { fen, depth, aiWorkerColor } = event.data;
      const key = normalizeFen(fen);

      const bookMoves = openingBook[key];
      if (bookMoves && bookMoves.length) {
        self.postMessage(shuffle(bookMoves.slice())[0]);
      } else {
        self.postMessage(minimaxRoot(depth, fen, aiWorkerColor));
      }
    };

    console.log('[Worker] AI Worker initialized with MVV/LVA + Killer Moves.');
    `;
      // --- Create and Manage the Worker ---
      function initializeAIWorker() {
        try {
          // Build a Blob from the workerCode (which itself does importScripts with CDN fallback)
          const blob = new Blob([workerCode], {type: "application/javascript"});
          const blobUrl = URL.createObjectURL(blob);

          // Spawn the worker
          aiWorker = new Worker(blobUrl);

          // Handle messages back from the worker
          aiWorker.onmessage = function (event) {
            aiThinking = false;
            gameStatusElement.textContent = "PLAYING vs AI";
            const bestMove = event.data;

            if (bestMove && bestMove.error) {
              console.error("Error reported from AI Worker:", bestMove.error);
              renderBoard();
              return;
            }

            console.log("Main thread received best move:", bestMove);

            // Sanity checks
            if (chess.game_over() || chess.turn() !== (aiColor === "black" ? "b" : "w")) {
              renderBoard();
              return;
            }

            // Apply the move
            if (bestMove) {
              const moveResult = chess.move(bestMove);
              if (moveResult) {
                if (moveResult.captured) {
                  pieceCaptureSound.currentTime = 0;
                  pieceCaptureSound.play().catch((e) => console.log("Audio error", e));
                } else {
                  playPutDownSound();
                }
                lastMove = {
                  from: squareToCoords(moveResult.from),
                  to: squareToCoords(moveResult.to),
                };
                updateCapturedPiecesFromMove(moveResult);
                updatePgnDisplay();
                renderBoard();
                triggerHapticFeedback();
              } else {
                console.error("Invalid move from AI Worker:", bestMove, "FEN:", chess.fen());
                renderBoard();
              }
            } else {
              console.error("AI Worker returned no move. FEN:", chess.fen());
              renderBoard();
              updateGameStatus();
            }
          };

          // If the worker itself errors out
          aiWorker.onerror = function (error) {
            console.error("Error in AI Worker:", error.message, error);
            aiThinking = false;
            renderBoard();
            alert("AI encountered an error and has been disabled.");
            gameMode = "human";
          };

          console.log("AI Worker created successfully using Blob URL.");
        } catch (e) {
          console.error("Failed to create inline worker:", e);
          // you can choose to fall back to human here or alert the user,
          // but do NOT unconditionally force gameMode = 'human'
        }
      }
      // --- End Worker Setup ---

      // --- Modified AI OPPONENT FUNCTIONS ---
      // Make AI move (Now uses the worker)
      function makeAIMove() {
        // Set thinking status before any processing
        aiThinking = true;
        renderBoard(); // Ensure status gets updated
        gameStatusElement.textContent = "AI THINKING";

        // 1) Try mate-in-one first:
        const mateMove = findMateInOne(chess);
        if (mateMove) {
          const result = chess.move(mateMove);
          if (result.captured) {
            pieceCaptureSound.currentTime = 0;
            pieceCaptureSound.play().catch(() => { });
          } else {
            playPutDownSound();
          }
          lastMove = {
            from: squareToCoords(result.from),
            to: squareToCoords(result.to)
          };
          updateCapturedPiecesFromMove(result);
          updatePgnDisplay();
          renderBoard();
          triggerHapticFeedback();
          return; // skip the worker entirely
        }
        // Determine AI’s turn token ("w" or "b")
        const aiTurn = aiColor.charAt(0);

        // Only request a move if it’s really the AI’s turn
        if (chess.game_over() || chess.turn() !== aiTurn || !aiWorker) {
          return;
        }

        aiThinking = true;
        selectedPiece = null;
        validMoves = [];
        renderBoard();

        const currentFen = chess.fen();
        const searchDepth = 3;

        aiWorker.postMessage({
          fen: currentFen,
          depth: searchDepth,
          aiWorkerColor: aiColor,
        });
      }

      // REMOVED: minimaxRoot, minimax, evaluatePosition, shuffleArray from the main thread
      // They are now defined inside the workerCode string.

      // --- Rendering and Game Logic (Mostly Unchanged) ---
      function renderBoard() {
        boardElement.innerHTML = "";
        const boardState = convertChessJsBoard();
        for (let row = 0; row < 8; row++) {
          const rowElement = document.createElement("div");
          rowElement.className = "row";
          for (let col = 0; col < 8; col++) {
            const squareElement = document.createElement("div");
            const isLightSquare = (row + col) % 2 === 0;
            squareElement.className = `square ${isLightSquare ? "light-square" : "dark-square"}`;
            squareElement.dataset.row = row;
            squareElement.dataset.col = col;
            const piece = boardState[row][col];
            if (piece) {
              const pieceElement = document.createElement("div");
              const pieceColor = getPieceColor(piece);
              pieceElement.className = `piece ${pieceColor}-piece`;
              pieceElement.textContent = pieceMapping[piece];
              squareElement.appendChild(pieceElement);
            }
            if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
              squareElement.classList.add("selected");
            }
            if (validMoves.some(([r, c]) => r === row && c === col)) {
              squareElement.classList.add("valid-move");
            }
            if (lastMove.from && row === lastMove.from[0] && col === lastMove.from[1]) {
              squareElement.classList.add("last-move-from");
            }
            if (lastMove.to && row === lastMove.to[0] && col === lastMove.to[1]) {
              squareElement.classList.add("last-move-to");
            }
            squareElement.addEventListener("click", () => handleSquareClick(row, col));
            rowElement.appendChild(squareElement);
          }
          boardElement.appendChild(rowElement);
        }
        updateGameStatus(); // Update status after rendering board
        updateCapturedPieces(); // Update captures after rendering board
      }

      function handleSquareClick(row, col) {
        // Don’t allow clicks when game over or AI is thinking
        if (chess.game_over() || (gameMode === "ai" && aiThinking)) return;

        const square = coordsToSquare(row, col);
        const piece = chess.get(square);

        // If no piece selected yet, attempt to select one
        if (!selectedPiece) {
          if (piece && piece.color === chess.turn()) {
            playPieceSound();
            selectedPiece = {row, col, square};
            validMoves = getValidMovesForSquare(row, col);
            renderBoard();
          }
          return;
        }

        // Attempt to move the selected piece
        const isValid = validMoves.some(([r, c]) => r === row && c === col);
        if (isValid) {
          const moveResult = chess.move({from: selectedPiece.square, to: square, promotion: "q"});
          if (moveResult) {
            // Play the appropriate sound
            if (moveResult.captured) {
              pieceCaptureSound.currentTime = 0;
              pieceCaptureSound.play().catch(() => { });
            } else {
              playPutDownSound();
            }

            lastMove = {
              from: squareToCoords(moveResult.from),
              to: squareToCoords(moveResult.to),
            };
            updateCapturedPiecesFromMove(moveResult);
            updatePgnDisplay();
            renderBoard();
            triggerHapticFeedback();

            // **AI’s turn check**: only call if it's truly AI's move next
            if (gameMode === "ai" && !chess.game_over() && chess.turn() === aiColor.charAt(0)) {
              setTimeout(makeAIMove, 200);
            }
          }
        } else {
          // Invalid square: either re‐select or clear selection
          if (piece && piece.color === chess.turn()) {
            playPieceSound();
            selectedPiece = {row, col, square};
            validMoves = getValidMovesForSquare(row, col);
          } else {
            selectedPiece = null;
            validMoves = [];
          }
          renderBoard();
        }
      }

      function updateGameStatus() {
        const currentTurn = chess.turn() === "w" ? "WHITE" : "BLACK";
        currentPlayerElement.textContent = currentTurn;
        let statusText = "";
        let isGameOver = false;
        let gameOverTitle = "";
        let gameOverReason = "";
        let gameResult = null;
        if (chess.in_checkmate()) {
          statusText = "CHECKMATE";
          isGameOver = true;
          gameOverTitle = "CHECKMATE";
          const winner = currentTurn === "WHITE" ? "BLACK" : "WHITE";
          gameOverReason = `${winner} WINS!`;
          gameResult =
            (winner === "WHITE" && aiColor === "black") || (winner === "BLACK" && aiColor === "white")
              ? "win"
              : "loss";
          if (
            gameResult === "win" &&
            chess.history({verbose: true}).length > 0 &&
            chess.history({verbose: true}).slice(-1)[0].piece === "p"
          )
            playerStats.checkmateWithPawn = true;
        } else if (chess.in_stalemate()) {
          statusText = "DRAW";
          isGameOver = true;
          gameOverTitle = "DRAW";
          gameOverReason = "STALEMATE";
          gameResult = "draw";
        } else if (chess.in_threefold_repetition()) {
          statusText = "DRAW";
          isGameOver = true;
          gameOverTitle = "DRAW";
          gameOverReason = "REPETITION";
          gameResult = "draw";
        } else if (chess.insufficient_material()) {
          statusText = "DRAW";
          isGameOver = true;
          gameOverTitle = "DRAW";
          gameOverReason = "INSUFFICIENT MATERIAL";
          gameResult = "draw";
        } else if (chess.in_draw()) {
          statusText = "DRAW";
          isGameOver = true;
          gameOverTitle = "DRAW";
          gameOverReason = "50-MOVE RULE";
          gameResult = "draw";
        } else if (chess.in_check()) {
          statusText = "CHECK";
        } else {
          statusText = gameMode === "ai" ? (aiThinking ? "AI THINKING" : "PLAYING vs AI") : "PLAYING";
        }
        gameStatusElement.textContent = statusText;
        if (isGameOver && !boardElement.querySelector(".checkmate-overlay")) {
          // Prevent multiple overlays
          if (gameMode === "ai") {
            const scoreResult = calculateGameScore(gameResult);
            gameScore = scoreResult.score;
            showScoringOverlay(scoreResult);
          } else {
            gameScore = 0;
          }
          showGameOverOverlay(gameOverTitle, gameOverReason);
        } else if ((!isGameOver && statusText === "CHECKMATE") || statusText === "DRAW") {
          // Add winner/draw text if not handled by overlay yet
          const reasonElement = document.createElement("div");
          reasonElement.className = "winner";
          reasonElement.textContent = gameOverReason || statusText;
          gameStatusElement.appendChild(reasonElement);
        }
      }

      function showGameOverOverlay(title, reason) {
        const overlay = document.createElement("div");
        overlay.className = "checkmate-overlay";
        const content = document.createElement("div");
        content.style.cssText = "display: flex; flex-direction: column; align-items: center; gap: 10px;";
        const titleElement = document.createElement("div");
        titleElement.className = "checkmate-text";
        titleElement.textContent = title;
        const reasonElement = document.createElement("div");
        reasonElement.className = "scoreboard-text";
        reasonElement.style.textAlign = "center";
        reasonElement.textContent = reason;
        const buttonContainer = document.createElement("div");
        buttonContainer.style.cssText = "display: flex; flex-direction: column; gap: 10px;";
        const newGameButton = document.createElement("button");
        newGameButton.className = "modal-button";
        newGameButton.textContent = "CONTINUE PLAYING";
        newGameButton.id = "new-game-checkmate";
        newGameButton.onclick = () => resetGame(false); // Use onclick for simplicity here
        content.appendChild(titleElement);
        content.appendChild(reasonElement);
        buttonContainer.appendChild(newGameButton);
        if (gameMode === "ai") {
          const submitScoreButton = document.createElement("button");
          submitScoreButton.className = "modal-button";
          submitScoreButton.textContent = "SUBMIT FINAL SCORE";
          submitScoreButton.onclick = function () {
            /* Submit score logic */
            this.disabled = true;
            this.textContent = "SUBMITTING...";
            updateFarcadeScore();
            const confirmationMsg = document.createElement("div");
            confirmationMsg.className = "winner";
            confirmationMsg.style.cssText = "font-size: 0.7rem; margin-top: 10px;";
            confirmationMsg.textContent = "SCORE SUBMITTED!";
            content.insertBefore(confirmationMsg, buttonContainer);
            this.style.display = "none";
            triggerHapticFeedback();
          };
          buttonContainer.appendChild(submitScoreButton);
        }
        content.appendChild(buttonContainer);
        overlay.appendChild(content);
        boardElement.appendChild(overlay);
        triggerHapticFeedback();
      }

      function resetGame(fullReset = false) {
        /* ... unchanged ... */
        chess = new Chess();
        selectedPiece = null;
        validMoves = [];
        lastMove = {from: null, to: null};
        aiThinking = false;
        gameScore = 0;
        capturedPieces = {white: [], black: []};
        playerStats.capturedPieces = {p: 0, n: 0, b: 0, r: 0, q: 0};
        playerStats.capturedPieceValue = 0;
        playerStats.startTime = Date.now();
        playerStats.consecutiveCaptures = 0;
        playerStats.lastCaptureMove = -1;
        playerStats.queenLost = false;
        playerStats.checkmateWithPawn = false;
        if (fullReset) {
          console.log("Full stats reset");
          playerStats.gamesPlayed = 0;
          playerStats.wins = 0;
          playerStats.draws = 0;
          playerStats.losses = 0;
          playerStats.currentWinStreak = 0;
          playerStats.highestWinStreak = 0;
          playerStats.quickWinsUnder30Moves = 0;
          playerStats.totalScore = 0;
          playerStats.achievements = [];
        }
        const scoreValue = document.querySelector(".score-value");
        if (scoreValue) scoreValue.textContent = "000";
        const scoreNotification = document.querySelector(".score-notification");
        if (scoreNotification) scoreNotification.textContent = "No Captures Yet";
        const submitFinalScoreButton = document.getElementById("submit-final-score");
        if (submitFinalScoreButton) {
          submitFinalScoreButton.disabled = false;
          submitFinalScoreButton.textContent = "SUBMIT SCORE";
          submitFinalScoreButton.style.display = "";
        }
        const pgnOutput = document.getElementById("full-pgn-output");
        if (pgnOutput) pgnOutput.textContent = "";
        if (lastPgnMoves) lastPgnMoves.textContent = "Last Moves";
        renderBoard();
        // If it's an AI game and AI plays as white, make the first move using the worker
        if (gameMode === "ai" && aiColor === "white") {
          setTimeout(makeAIMove, 500);
        }
        const existingOverlay = boardElement.querySelector(".checkmate-overlay");
        if (existingOverlay) boardElement.removeChild(existingOverlay);
      }

      // --- Touch Handlers (Unchanged) ---
      let activeGhost = null;
      let isPieceBeingDragged = false;
      boardElement.addEventListener("touchstart", (e) => {
        /* ... unchanged ... */
        if (chess.game_over() || aiThinking) return;
        const touch = e.touches[0];
        const element = document.elementFromPoint(touch.clientX, touch.clientY);
        if (!element || !element.classList.contains("piece")) return;
        const square = element.parentElement;
        const row = parseInt(square.dataset.row);
        const col = parseInt(square.dataset.col);
        const algebraicSquare = coordsToSquare(row, col);
        const piece = chess.get(algebraicSquare);
        if (!piece || piece.color !== chess.turn()) return;
        playPieceSound();
        e.preventDefault();
        isPieceBeingDragged = true;
        selectedPiece = {row, col, piece: getPieceNotation(piece), square: algebraicSquare};
        validMoves = getValidMovesForSquare(row, col);
        activeGhost = element.cloneNode(true);
        activeGhost.classList.add("ghost-piece");
        activeGhost.style.left = `${touch.clientX}px`;
        activeGhost.style.top = `${touch.clientY}px`;
        document.body.appendChild(activeGhost);
        element.classList.add("dragging");
        validMoves.forEach(([r, c]) => {
          const targetSquare = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
          if (targetSquare) {
            const targetPiece = chess.get(coordsToSquare(r, c));
            if (targetPiece) {
              targetSquare.classList.add("capture-highlight");
            } else {
              targetSquare.classList.add("valid-drop");
            }
          }
        });
      });
      document.addEventListener("touchmove", (e) => {
        /* ... unchanged ... */
        if (!activeGhost || !isPieceBeingDragged) return;
        e.preventDefault();
        const touch = e.touches[0];
        activeGhost.style.left = `${touch.clientX}px`;
        activeGhost.style.top = `${touch.clientY}px`;
        const targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
        document.querySelectorAll(".square").forEach((s) => s.classList.remove("valid-drop", "capture-highlight"));
        if (targetElement) {
          const square = targetElement.closest(".square");
          if (square) {
            const row = parseInt(square.dataset.row);
            const col = parseInt(square.dataset.col);
            const isValid = validMoves.some(([r, c]) => r === row && c === col);
            if (isValid) {
              const targetPiece = chess.get(coordsToSquare(row, col));
              if (targetPiece) {
                square.classList.add("capture-highlight");
              } else {
                square.classList.add("valid-drop");
              }
            }
          }
        }
      });
      document.addEventListener("touchend", (e) => {
        /* ... unchanged ... */
        if (!activeGhost || !isPieceBeingDragged || !selectedPiece) return;
        e.preventDefault();
        isPieceBeingDragged = false;
        document.body.removeChild(activeGhost);
        activeGhost = null;
        const originalPiece = document.querySelector(".piece.dragging");
        if (originalPiece) originalPiece.classList.remove("dragging");
        const touch = e.changedTouches[0];
        const targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
        document.querySelectorAll(".square").forEach((s) => s.classList.remove("valid-drop", "capture-highlight")); // Clear highlights
        if (!targetElement) {
          selectedPiece = null;
          validMoves = [];
          renderBoard();
          return;
        }
        const square = targetElement.closest(".square");
        if (!square) {
          selectedPiece = null;
          validMoves = [];
          renderBoard();
          return;
        }
        const toRow = parseInt(square.dataset.row);
        const toCol = parseInt(square.dataset.col);
        const toSquare = coordsToSquare(toRow, toCol);
        const isValid = validMoves.some(([r, c]) => r === toRow && c === toCol);
        if (isValid) {
          /* Make move */
          const moveResult = chess.move({from: selectedPiece.square, to: toSquare, promotion: "q"});
          if (moveResult) {
            if (moveResult.captured) {
              pieceCaptureSound.currentTime = 0;
              pieceCaptureSound.play().catch((e) => console.log("Audio error", e));
            } else {
              playPutDownSound();
            }
            lastMove = {from: squareToCoords(moveResult.from), to: squareToCoords(moveResult.to)};
            updateCapturedPiecesFromMove(moveResult);
            updatePgnDisplay();
            selectedPiece = null;
            validMoves = [];
            renderBoard();
            triggerHapticFeedback();
            if (gameMode === "ai" && !chess.game_over() && chess.turn() === (aiColor === "black" ? "b" : "w")) {
              setTimeout(makeAIMove, 500);
            } /* Trigger AI */
          }
        } else {
                /* Invalid move */ selectedPiece = null;
          validMoves = [];
          renderBoard();
        }
      });

      // --- Event Listeners (Mostly Unchanged) ---
      menuButton.addEventListener("click", () => {
        /* ... unchanged ... */
        menuModal.classList.add("active");
        if (gameMode === "human") {
          modeHumanButton.classList.add("active");
          modeAIButton.classList.remove("active");
          aiOptionsContainer.style.display = "none";
        } else {
          modeAIButton.classList.add("active");
          modeHumanButton.classList.remove("active");
          aiOptionsContainer.style.display = "block";
          if (aiColor === "white") {
            aiColorWhiteButton.classList.add("active");
            aiColorBlackButton.classList.remove("active");
          } else {
            aiColorBlackButton.classList.add("active");
            aiColorWhiteButton.classList.remove("active");
          }
        }
      });
      closeModalButton.addEventListener("click", () => menuModal.classList.remove("active"));
      newGameModalButton.addEventListener("click", () => {
        resetGame(false);
        menuModal.classList.remove("active");
      });
      modeHumanButton.addEventListener("click", () => {
        gameMode = "human";
        modeHumanButton.classList.add("active");
        modeAIButton.classList.remove("active");
        aiOptionsContainer.style.display = "none";
      });
      modeAIButton.addEventListener("click", () => {
        gameMode = "ai";
        modeAIButton.classList.add("active");
        modeHumanButton.classList.remove("active");
        aiOptionsContainer.style.display = "block";
      });
      aiColorWhiteButton.addEventListener("click", () => {
        aiColor = "white";
        aiColorWhiteButton.classList.add("active");
        aiColorBlackButton.classList.remove("active");
      });
      aiColorBlackButton.addEventListener("click", () => {
        aiColor = "black";
        aiColorBlackButton.classList.add("active");
        aiColorWhiteButton.classList.remove("active");
      });
      welcomeColorWhiteButton.addEventListener("click", () => {
        aiColor = "white";
        updateWelcomeScreen();
      });
      welcomeColorBlackButton.addEventListener("click", () => {
        aiColor = "black";
        updateWelcomeScreen();
      });
      startGameButton.addEventListener("click", () => {
        welcomeOverlay.classList.remove("active");
        resetGame();
        startBackgroundMusic();
      });
      document.getElementById("reset-stats-button").addEventListener("click", () => {
        if (confirm("Are you sure?")) resetAllStats();
      });
      document.getElementById("view-stats-button").addEventListener("click", () => {
        showStatsOverlay();
        menuModal.classList.remove("active");
      });
      pgnButton.addEventListener("click", () => {
        const fullPgn = chess.pgn();
        fullPgnOutput.textContent = fullPgn || "No moves yet";
        pgnModal.classList.add("active");
      });
      closePgnModal.addEventListener("click", () => pgnModal.classList.remove("active"));
      document.getElementById("submit-final-score").addEventListener("click", function () {
        /* ... unchanged submit logic ... */
        this.disabled = true;
        this.textContent = "SUBMITTING...";
        updateFarcadeScore();
        const confirmationMsg = document.createElement("div");
        confirmationMsg.className = "winner";
        confirmationMsg.style.cssText = "font-size: 0.7rem; margin-top: 10px;";
        confirmationMsg.textContent = "SCORE SUBMITTED!";
        document.getElementById("score-breakdown").appendChild(confirmationMsg);
        this.style.display = "none";
        setTimeout(() => {
          document.getElementById("scoring-overlay").classList.remove("active");
        }, 2000);
        triggerHapticFeedback();
      });
      document.querySelectorAll("button").forEach((button) => button.addEventListener("click", playButtonClickSound));
      // Start music on first interaction (outside SDK init)
      document.body.addEventListener(
        "click",
        function startMusicOnFirstClick() {
          startBackgroundMusic();
          document.body.removeEventListener("click", startMusicOnFirstClick); // Remove listener after first click
        },
        {once: true, capture: true},
      ); // Use capture to ensure it runs, once to self-remove

      // --- Initialization ---
      function updateWelcomeScreen() {
        /* ... unchanged ... */
        if (aiColor === "white") {
          welcomeColorWhiteButton.classList.add("active");
          welcomeColorBlackButton.classList.remove("active");
        } else {
          welcomeColorBlackButton.classList.add("active");
          welcomeColorWhiteButton.classList.remove("active");
        }
      }
      updateWelcomeScreen();
      loadPlayerStats(); // Load stats (currently does nothing in arcade mode)

      // Initialize AI Worker *after* the rest of the script is parsed
      initializeAIWorker();

      // Initial render
      renderBoard();

      // Set initial UI state for AI options based on defaults
      aiOptionsContainer.style.display = gameMode === "ai" ? "block" : "none";
      if (gameMode === "ai") {
        modeAIButton.classList.add("active");
        modeHumanButton.classList.remove("active");
      } else {
        modeHumanButton.classList.add("active");
        modeAIButton.classList.remove("active");
      }
      if (aiColor === "black") {
        aiColorBlackButton.classList.add("active");
        aiColorWhiteButton.classList.remove("active");
      } else {
        aiColorWhiteButton.classList.add("active");
        aiColorBlackButton.classList.remove("active");
      }

      // If AI should play first, trigger its move (now using worker)
      // Note: This happens *after* worker initialization attempt.
      // If worker failed, resetGame might switch to human mode anyway.
      if (gameMode === "ai" && aiColor === "white") {
        setTimeout(makeAIMove, 500);
      }

      // Farcade SDK Integration
      window.addEventListener("DOMContentLoaded", () => {
        if (window.FarcadeSDK) {
          // Signal ready
          window.FarcadeSDK.singlePlayer.actions.ready();
          console.log("Farcade SDK Ready signal sent.");

          // Handle play_again
          window.FarcadeSDK.on("play_again", () => {
            console.log("Farcade: Received play_again event.");
            resetGame(true); // Full reset including stats
          });

          // Handle toggle_mute
          window.FarcadeSDK.on("toggle_mute", (data) => {
            isMuted = data.isMuted;
            console.log("Farcade: Game " + (isMuted ? "muted" : "unmuted"));
            if (isMuted) {
              backgroundMusic.pause();
            } else {
              startBackgroundMusic();
            } // Attempt to play if unmuted
          });
        } else {
          console.warn("Farcade SDK not detected.");
        }
      });
    })(); // End of IIFE scope wrapper
  </script>
</body>

</html>