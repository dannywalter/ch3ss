<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
    <title>CH3SS</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />
    <script src="https://unpkg.com/@farcade/game-sdk@latest/dist/index.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.js"></script>
    <style>
      /* Global Styles */
      *,
      *::before,
      *::after {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      html {
        -webkit-text-size-adjust: none;
        text-size-adjust: none;
      }

      body {
        width: 100%;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        background: linear-gradient(135deg, #120025 0%, #050520 100%);
        font-family: "Press Start 2P", monospace;
        color: #00ffff;
        overflow: hidden;
        padding: 0px;
      }

      /* Arcade Cabinet Styling - Mobile First Approach */
      .arcade {
        max-width: 400px;
        max-height: 800px;
        width: 100%;
        height: auto;
        padding: 5px;
        border-radius: 10px;
        box-shadow:
          0 0 20px #ff00ff,
          0 0 30px rgba(0, 255, 255, 0.5) inset;
        background: rgba(0, 0, 0, 0.8);
        border: 2px solid #ff00ff;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        /* Logical canvas size for game elements */
        --canvas-width: 500px;
        --canvas-height: 800px;
        aspect-ratio: 500 / 800;
      }

      .title {
        text-align: center;
        font-size: 1.5rem;
        margin-bottom: 15px;
        font-weight: bold;
        text-shadow:
          0 0 10px #00ffff,
          0 0 20px #ff00ff;
        letter-spacing: 0.1em;
      }

      /* Game Area */
      .game-area {
        display: flex;
        flex-direction: column;
        gap: 15px;
        justify-content: center;
        align-items: center;
        width: 100%;
      }

      /* Board Styling - Responsive */
      .board {
        display: flex;
        flex-direction: column;
        border: 2px solid #00ffff;
        box-shadow:
          0 0 15px #00ffff,
          0 0 5px rgba(0, 255, 255, 0.5) inset;
        position: relative;
        width: 100%;
        max-width: 360px; /* Maximized size for 400px container width */
        margin: 0 auto;
        touch-action: none;
      }

      .row {
        display: flex;
        width: 100%;
      }

      .square {
        width: 12.5%; /* 100% ÷ 8 squares */
        position: relative;
        padding-bottom: 12.5%; /* Makes squares perfect */
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .piece {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80%; /* Percentage of square size */
        height: 80%; /* Maintain aspect ratio */
        display: flex;
        justify-content: center;
        align-items: center;
        user-select: none;
        -webkit-user-select: none;
        -ms-user-select: none;
        /* Use viewport-relative font sizing with a minimum */
        font-size: clamp(16px, 4.5vmin, 32px);
        line-height: 1;
        cursor: grab;
      }

      .light-square {
        background: #00ffff10;
        box-shadow: 0 0 5px #00ffff inset;
      }

      .dark-square {
        background: #00000080;
      }

      .selected {
        background: #ff00ff80 !important;
        box-shadow:
          0 0 15px #ff00ff,
          0 0 5px #ff00ff inset !important;
      }

      .last-move-from {
        background: rgba(255, 255, 255, 0.3) !important;
        box-shadow:
          0 0 10px rgba(255, 255, 255, 0.5),
          0 0 5px rgba(255, 255, 255, 0.5) inset !important;
      }

      .last-move-to {
        background: rgba(255, 255, 255, 0.4) !important;
        box-shadow:
          0 0 10px rgba(255, 255, 255, 0.6),
          0 0 5px rgba(255, 255, 255, 0.6) inset !important;
      }

      .valid-move {
        background: #00ff0040 !important;
        box-shadow:
          0 0 15px #00ff00,
          0 0 5px #00ff00 inset !important;
      }

      .white-piece {
        color: #ffffff;
        text-shadow:
          0 0 5px #00ffff,
          0 0 10px #00ffff;
      }

      .black-piece {
        color: #ff50f0;
        text-shadow:
          0 0 5px #ff00ff,
          0 0 10px #ff00ff;
      }

      /* Game Info Panel */
      .info-container {
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 5px;
        width: 100%;
        max-width: 360px;
      }

      .display {
        border: 2px solid #00ffff;
        border-radius: 5px;
        box-shadow:
          0 0 10px #00ffff,
          0 0 5px rgba(0, 255, 255, 0.3) inset;
        overflow: hidden;
      }

      .display-header {
        font-size: 0.45rem;
        background: #00ffff20;
        padding: 3px 6px;
        border-bottom: 1px solid #00ffff;
        text-align: center;
      }

      .display-content {
        font-size: 0.65rem;
        padding: 5px;
        text-align: center;
        text-shadow: 0 0 5px #00ffff;
        letter-spacing: 0.1em;
        min-height: 22px;
      }

      .info-row {
        display: flex;
        gap: 8px;
        width: 100%;
        margin-bottom: 8px;
      }

      .info-panel {
        flex: 1;
      }

      .rules-content {
        font-size: 0.45rem;
        line-height: 1.5;
        color: #ff99ff;
        text-shadow: 0 0 3px #ff00ff;
        text-align: left;
        padding: 6px;
      }

      .menu-content {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 6px;
      }

      .menu-inline-button {
        background: transparent;
        color: #ff00ff;
        border: 1px solid #ff00ff;
        padding: 4px 8px;
        font-size: 0.5rem;
        border-radius: 3px;
        cursor: pointer;
        box-shadow: 0 0 3px #ff00ff;
        font-family: "Press Start 2P", monospace;
        transition: all 0.3s ease;
        text-shadow: 0 0 3px #ff00ff;
      }

      .menu-inline-button:hover {
        background: #ff00ff20;
        box-shadow: 0 0 6px #ff00ff;
      }

      /* Captured Pieces Display */
      .captured-container {
        display: flex;
        flex-direction: column;
        gap: 8px;
        width: 100%;
      }

      .captured-display {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
        width: 100%;
        position: relative;
      }

      .captured-pieces {
        font-size: 0.6rem;
        display: flex;
        flex-wrap: wrap;
        gap: 3px;
        padding: 2px;
        min-height: 22px;
        flex: 1;
      }

      .score-display {
        font-size: 0.6rem;
        margin-left: 5px;
        margin-right: 5px;
      }

      .score-white {
        color: #ffffff;
        text-shadow: 0 0 5px #00ffff;
      }

      .score-black {
        color: #ff50f0;
        text-shadow: 0 0 5px #ff00ff;
      }

      .scoreboard {
        border: 2px solid #ff00ff;
        border-radius: 5px;
        box-shadow:
          0 0 10px #ff00ff,
          0 0 5px rgba(255, 0, 255, 0.3) inset;
        margin-top: 5px;
        overflow: hidden;
      }

      .scoreboard-text {
        font-size: 0.75rem;
        padding: 20px 50px 20px 50px;
        line-height: 2;
        color: #ff99ff;
        text-shadow: 0 0 3px #ff00ff;
        text-align: center;
      }

      .winner {
        color: #ff00ff;
        margin-top: 5px;
        font-size: 0.6rem;
        font-weight: bold;
        text-shadow:
          0 0 8px #ff00ff,
          0 0 4px #ffffff;
        animation: pulse 1.5s infinite alternate;
      }

      /* Game Controls */
      .controls {
        margin-top: 10px;
        display: flex;
        justify-content: center;
        width: 100%;
      }

      .button {
        background: transparent;
        color: #ff00ff;
        border: 2px solid #ff00ff;
        padding: 8px 15px;
        font-size: 0.7rem;
        border-radius: 5px;
        cursor: pointer;
        box-shadow: 0 0 5px #ff00ff;
        font-family: "Press Start 2P", monospace;
        transition: all 0.3s ease;
        text-shadow: 0 0 5px #ff00ff;
      }

      .button:hover,
      .button:active {
        background: #ff00ff20;
        box-shadow:
          0 0 10px #ff00ff,
          0 0 5px #ff00ff inset;
      }

      /* Modal Styles */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 100;
        animation: fadeIn 0.3s ease-in-out;
      }

      .modal-overlay.active {
        display: flex;
      }

      .modal {
        background: #120318;
        border: 2px solid #00ffff;
        box-shadow:
          0 0 20px #00ffff,
          0 0 10px rgba(0, 255, 255, 0.5) inset;
        border-radius: 5px;
        width: 90%;
        max-width: 350px;
        max-height: 90vh;
        overflow-y: auto;
        animation: scaleIn 0.3s ease-out;
        padding: 15px;
        color: #ffffff;
      }

      .modal-header {
        font-size: 0.9rem;
        color: #00ffff;
        text-shadow: 0 0 5px #00ffff;
        text-align: center;
        margin-bottom: 15px;
        border-bottom: 1px solid #00ffff50;
        padding-bottom: 10px;
      }

      .modal-section {
        margin-bottom: 15px;
        border-bottom: 1px solid #ff00ff30;
        padding-bottom: 10px;
      }

      .modal-section-title {
        font-size: 0.6rem;
        color: #ff00ff;
        text-shadow: 0 0 3px #ff00ff;
        margin-bottom: 8px;
      }

      .modal-content {
        font-size: 0.5rem;
        line-height: 1.4;
        color: #dddddd;
      }

      .modal-buttons {
        display: flex;
        justify-content: space-between;
        margin-top: 15px;
      }

      .modal-button {
        background: transparent;
        border: 1px solid #00ffff;
        color: #00ffff;
        padding: 5px 10px;
        font-size: 0.5rem;
        border-radius: 3px;
        cursor: pointer;
        font-family: "Press Start 2P", monospace;
        transition: all 0.2s;
        text-shadow: 0 0 3px #00ffff;
      }

      .modal-button:hover {
        background: #00ffff20;
        box-shadow: 0 0 8px #00ffff;
      }

      .modal-button.danger {
        border-color: #ff00ff;
        color: #ff00ff;
        text-shadow: 0 0 3px #ff00ff;
      }

      .modal-button.danger:hover {
        background: #ff00ff20;
        box-shadow: 0 0 8px #ff00ff;
      }

      /* Game mode options */
      .option-group {
        margin: 10px 0;
      }

      .option-label {
        font-size: 0.45rem;
        color: #00ffff;
        margin-bottom: 5px;
      }

      .option-buttons {
        display: flex;
        flex-direction: column;
        gap: 5px;
      }

      .option-button {
        background: transparent;
        border: 1px solid #666;
        color: #aaa;
        padding: 4px 8px;
        font-size: 0.45rem;
        cursor: pointer;
        font-family: "Press Start 2P", monospace;
        transition: all 0.2s;
        text-align: center;
      }

      .option-button.active {
        border-color: #00ffff;
        color: #00ffff;
        box-shadow: 0 0 5px #00ffff;
      }

      .spacer-small {
        height: 10px;
      }

      @keyframes scaleIn {
        from {
          transform: scale(0.8);
          opacity: 0;
        }
        to {
          transform: scale(1);
          opacity: 1;
        }
      }

      /* Checkmate Overlay */
      .checkmate-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.6);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10;
        animation: fadeIn 0.5s ease-in-out;
      }

      .checkmate-text {
        color: #ff00ff;
        font-size: 1.2rem;
        font-weight: bold;
        text-shadow:
          0 0 10px #ff00ff,
          0 0 20px #ff00ff,
          0 0 30px #ff00ff;
        padding: 15px;
        border: 2px solid #ff00ff;
        border-radius: 5px;
        background: rgba(0, 0, 0, 0.8);
        box-shadow:
          0 0 20px #ff00ff,
          0 0 10px rgba(255, 0, 255, 0.5) inset;
      }

      /* Animations */
      @keyframes pulse {
        from {
          opacity: 0.7;
          text-shadow: 0 0 5px #ff00ff;
        }
        to {
          opacity: 1;
          text-shadow:
            0 0 15px #ff00ff,
            0 0 25px #ffffff;
        }
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      /* Media Queries for Responsive Design - Tablet & Desktop */
      @media (max-width: 480px) {
        .piece {
          /* Adjust for smaller screens */
          width: 75%;
          height: 75%;
          font-size: clamp(14px, 8vmin, 28px);
        }
      }

      @media screen and (-webkit-min-device-pixel-ratio: 2) {
        .piece {
          /* Adjust for high DPI screens */
          font-size: clamp(14px, 9vmin, 32px);
        }
      }

      @media screen and (-webkit-min-device-pixel-ratio: 3) {
        .piece {
          /* Adjust for even higher DPI screens (iPhone) */
          font-size: clamp(14px, 10vmin, 42px);
          top: 40%;
        }
      }

      @media (min-width: 481px) {
        .arcade {
          padding: 8px;
        }

        .title {
          font-size: 1.8rem;
          margin-bottom: 20px;
          letter-spacing: 0.2em;
        }

        .piece {
          font-size: 24px;
        }

        .display-header {
          font-size: 0.6rem;
        }

        .display-content {
          font-size: 0.8rem;
        }

        .scoreboard-text {
          font-size: 0.5rem;
          padding: 10px;
        }

        .button {
          padding: 10px 20px;
          font-size: 0.8rem;
        }
      }

      @media (min-width: 768px) {
        .game-area {
          flex-direction: row;
          justify-content: center;
          align-items: flex-start;
        }

        .info-container {
          width: 180px;
        }

        .arcade {
          display: block;
        }
      }

      /* Touch drag and drop styles */
      .ghost-piece {
        position: fixed;
        pointer-events: none;
        z-index: 1000;
        opacity: 0.8;
        transform: translate(-50%, -65%) scale(3.1);
        transition: transform 0.1s ease;
      }

      .piece.dragging {
        opacity: 0.3;
      }

      .square.valid-drop {
        background: rgba(0, 255, 0, 0.2) !important;
        box-shadow: 0 0 15px 10px #00ff00 !important;
      }

      .square.capture-highlight {
        background: rgba(255, 0, 0, 0.3) !important;
        box-shadow: 0 0 15px 10px #ff0000 !important;
        animation: captureFlash 0.3s ease;
      }

      @keyframes captureFlash {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.1);
        }
        100% {
          transform: scale(1);
        }
      }
    </style>
  </head>
  <body>
    <div class="arcade">
      <div class="title">CH3SS</div>
      <div class="game-area">
        <div id="board" class="board"></div>
        <div class="info-container">
          <!-- Row 1: Player - Status -->
          <div class="info-row">
            <div class="info-panel">
              <div class="display">
                <div class="display-header">PLAYER</div>
                <div id="current-player" class="display-content">WHITE</div>
              </div>
            </div>
            <div class="info-panel">
              <div class="display">
                <div class="display-header">STATUS</div>
                <div id="game-status" class="display-content">PLAYING vs AI</div>
              </div>
            </div>
          </div>

          <!-- Row 2: White Captured - Black Captured -->
          <div class="info-row">
            <div class="info-panel">
              <div class="display">
                <div class="display-header">WHITE CAPTURED</div>
                <div class="display-content captured-display">
                  <div id="white-captured" class="captured-pieces white-piece"></div>
                  <div id="white-score" class="score-display score-white">+0</div>
                </div>
              </div>
            </div>
            <div class="info-panel">
              <div class="display">
                <div class="display-header">BLACK CAPTURED</div>
                <div class="display-content captured-display">
                  <div id="black-captured" class="captured-pieces black-piece"></div>
                  <div id="black-score" class="score-display score-black">+0</div>
                </div>
              </div>
            </div>
          </div>

          <!-- Row 3: CyberChess - Menu -->
          <div class="info-row">
            <div class="info-panel">
              <div class="display">
                <div class="display-header">CH3SS</div>
                <div class="display-content rules-content">
                  <div
                    id="pgn-output"
                    style="font-size: 0.45rem; color: #00ffff; text-align: center; margin-top: 0px"
                  ></div>
                </div>
              </div>
            </div>
            <div class="info-panel">
              <div class="display">
                <div class="display-header">MENU</div>
                <div class="display-content menu-content">
                  <button id="menu-button" class="menu-inline-button">OPTIONS</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Game Menu Modal -->
    <div id="menu-modal" class="modal-overlay">
      <div class="modal">
        <div class="modal-header">CH3SS MENU</div>

        <div class="modal-section">
          <div class="modal-section-title">GAME OPTIONS</div>
          <div class="modal-content">
            <div class="option-group">
              <div class="option-label">GAME MODE:</div>
              <div class="option-buttons">
                <button id="mode-human" class="option-button active">HUMAN VS HUMAN</button>
                <button id="mode-ai" class="option-button">HUMAN VS AI</button>
              </div>
            </div>

            <div id="ai-options" class="option-group" style="display: none">
              <div class="option-label">PLAY AS:</div>
              <div class="option-buttons">
                <button id="ai-color-white" class="option-button active">WHITE (YOU PLAY FIRST)</button>
                <button id="ai-color-black" class="option-button">BLACK (AI PLAYS FIRST)</button>
              </div>
            </div>
            <div class="spacer-small"></div>
            <button id="new-game-modal" class="modal-button">NEW GAME</button>
          </div>
        </div>

        <div class="modal-section">
          <div class="modal-section-title">GAME RULES</div>
          <div class="modal-content">
            Standard chess rules apply in a cyberpunk setting:<br /><br />
            • Each piece has a unique movement pattern<br />
            • Pawns move forward one square, capture diagonally<br />
            • Knights move in an L-shape, can jump over pieces<br />
            • Bishops move diagonally any number of squares<br />
            • Rooks move horizontally or vertically<br />
            • Queens combine bishop and rook moves<br />
            • Kings move one square in any direction<br />
            • Checkmate happens when the king is threatened with capture and can't escape
          </div>
        </div>

        <div class="modal-section">
          <div class="modal-section-title">SPECIAL MOVES</div>
          <div class="modal-content">
            • Castling: King moves two squares toward a rook, and the rook moves to the other side of the king<br />
            • En Passant: Pawns can capture an opponent's pawn that has moved two squares forward in one move<br />
            • Pawn Promotion: When a pawn reaches the opposite end of the board, it can be promoted to any other piece
          </div>
        </div>

        <div class="modal-section">
          <div class="modal-section-title">PIECE VALUES</div>
          <div class="modal-content">
            • Pawn: 1 point<br />
            • Knight: 3 points<br />
            • Bishop: 3 points<br />
            • Rook: 5 points<br />
            • Queen: 9 points<br />
            • King: Infinite (game lost if checkmate)
          </div>
        </div>

        <div class="modal-buttons">
          <button id="close-modal" class="modal-button">CLOSE</button>
        </div>
      </div>
    </div>

    <script>
      // Chess Game Logic using chess.js
      
      // Create a new chess instance
      let chess = new Chess();
      
      // Unicode mapping for chess pieces
      const pieceMapping = {
        k: "♚",
        q: "♛",
        r: "♖",
        b: "♗",
        n: "♘",
        p: "♙",
        K: "♚",
        Q: "♛",
        R: "♖",
        B: "♗",
        N: "♘",
        P: "♙",
      };

      // Game state variables
      let selectedPiece = null;
      let validMoves = [];
      let lastMove = {
        from: null,
        to: null,
      };
      
      // AI variables
      let gameMode = "ai"; // human, ai
      let aiColor = "black"; // AI will play as black by default
      let aiThinking = false; // Flag to prevent interactions while AI is thinking
      
      // Farcade SDK variables
      let isMuted = false; // Track if sound is muted
      let gameScore = 0; // Track player's score
      
      // Track captured pieces
      let capturedPieces = {
        white: [], // Pieces captured by white player
        black: [], // Pieces captured by black player
      };
      
      // DOM Elements
      const boardElement = document.getElementById("board");
      const currentPlayerElement = document.getElementById("current-player");
      const gameStatusElement = document.getElementById("game-status");
      const menuButton = document.getElementById("menu-button");
      const menuModal = document.getElementById("menu-modal");
      const newGameModalButton = document.getElementById("new-game-modal");
      const closeModalButton = document.getElementById("close-modal");
      const whiteCapturedElement = document.getElementById("white-captured");
      const blackCapturedElement = document.getElementById("black-captured");
      const whiteScoreElement = document.getElementById("white-score");
      const blackScoreElement = document.getElementById("black-score");

      // Helper Functions
      
      // Returns the color of a piece ('white', 'black', or null if empty)
      function getPieceColor(piece) {
        if (!piece) return null;
        return piece === piece.toUpperCase() ? "white" : "black";
      }
      
      // Get piece notation from chess.js piece object
      function getPieceNotation(piece) {
        if (!piece) return null;
        return piece.color === 'w' ? piece.type.toUpperCase() : piece.type.toLowerCase();
      }
      
      // Convert algebraic notation (e.g., "e4") to row/col coordinates
      function squareToCoords(square) {
        const col = square.charCodeAt(0) - 'a'.charCodeAt(0);
        const row = 8 - parseInt(square.charAt(1));
        return [row, col];
      }
      
      // Convert row/col coordinates to algebraic notation
      function coordsToSquare(row, col) {
        const file = String.fromCharCode('a'.charCodeAt(0) + col);
        const rank = 8 - row;
        return file + rank;
      }
      
      // Debugging function
      function debugLog(message, data = null) {
        const timestamp = new Date().toISOString().split("T")[1].split(".")[0];
        console.log(`[${timestamp}] ${message}`, data ? data : "");
      }
      
      // Convert chess.js board to our UI representation
      function convertChessJsBoard() {
        const board = chess.board();
        const convertedBoard = Array(8).fill().map(() => Array(8).fill(null));
        
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            const piece = board[row][col];
            if (piece) {
              // Convert chess.js piece to our notation (uppercase for white, lowercase for black)
              convertedBoard[row][col] = piece.color === 'w' ? piece.type.toUpperCase() : piece.type.toLowerCase();
            }
          }
        }
        
        return convertedBoard;
      }
      
      // Function to get valid moves for a specific square
      function getValidMovesForSquare(row, col) {
        const square = coordsToSquare(row, col);
        const moves = chess.moves({
          square: square,
          verbose: true
        });
        
        // Convert moves to our format [row, col]
        return moves.map(move => squareToCoords(move.to));
      }
      
      // Update captured pieces based on move
      function updateCapturedPiecesFromMove(move) {
        if (move.captured) {
          const capturedPiece = move.color === 'w' ? move.captured.toLowerCase() : move.captured.toUpperCase();
          if (move.color === 'w') {
            capturedPieces.white.push(capturedPiece);
          } else {
            capturedPieces.black.push(capturedPiece);
          }
        }
      }

      // Render the chessboard on the screen
      function renderBoard() {
        boardElement.innerHTML = "";
        
        const boardState = convertChessJsBoard();
        
        for (let row = 0; row < 8; row++) {
          const rowElement = document.createElement("div");
          rowElement.className = "row";
          
          for (let col = 0; col < 8; col++) {
            const squareElement = document.createElement("div");
            const isLightSquare = (row + col) % 2 === 0;
            
            squareElement.className = `square ${isLightSquare ? "light-square" : "dark-square"}`;
            squareElement.dataset.row = row;
            squareElement.dataset.col = col;
            
            const piece = boardState[row][col];
            if (piece) {
              const pieceElement = document.createElement("div");
              const pieceColor = getPieceColor(piece);
              
              pieceElement.className = `piece ${pieceColor}-piece`;
              pieceElement.textContent = pieceMapping[piece];
              squareElement.appendChild(pieceElement);
            }
            
            // Visual highlights
            if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
              squareElement.classList.add("selected");
            }
            
            if (validMoves.some(([r, c]) => r === row && c === col)) {
              squareElement.classList.add("valid-move");
            }
            
            if (lastMove.from && row === lastMove.from[0] && col === lastMove.from[1]) {
              squareElement.classList.add("last-move-from");
            }
            
            if (lastMove.to && row === lastMove.to[0] && col === lastMove.to[1]) {
              squareElement.classList.add("last-move-to");
            }
            
            squareElement.addEventListener("click", () => handleSquareClick(row, col));
            rowElement.appendChild(squareElement);
          }
          
          boardElement.appendChild(rowElement);
        }
        
        updateGameStatus();
        updateCapturedPieces();
      }
      
      // Handle square clicks for moving pieces
      function handleSquareClick(row, col) {
        // Don't allow moves if the game is over or if it's AI's turn and AI is thinking
        if (chess.game_over() || (gameMode === "ai" && chess.turn() === (aiColor === "black" ? 'b' : 'w') && aiThinking)) {
          return;
        }
        
        const currentPlayerColor = chess.turn() === 'w' ? "white" : "black";
        const square = coordsToSquare(row, col);
        const piece = chess.get(square);
        
        // If no piece is selected yet, try to select one
        if (!selectedPiece) {
          // Can only select pieces of the current player's color
          if (piece && piece.color === chess.turn()) {
            selectedPiece = { row, col, piece: getPieceNotation(piece), square };
            
            // Calculate valid moves for the selected piece
            validMoves = getValidMovesForSquare(row, col);
            
            renderBoard();
          }
          return;
        }
        
        // If a piece is already selected, try to move it
        const isValidMove = validMoves.some(([r, c]) => r === row && c === col);
        
        if (isValidMove) {
          // Make the move
          const moveResult = chess.move({
            from: selectedPiece.square,
            to: square,
            promotion: 'q' // Auto-promote to queen for simplicity
          });
          
          if (moveResult) {
            // Update last move for highlighting
            lastMove = {
              from: squareToCoords(moveResult.from),
              to: squareToCoords(moveResult.to)
            };
            
            // Update captured pieces
            updateCapturedPiecesFromMove(moveResult);
            
            // Trigger haptic feedback
            triggerHapticFeedback();
            
            // Update PGN output
            const pgnOutput = document.getElementById("pgn-output");
            if (pgnOutput) {
              pgnOutput.textContent = "PGN: " + chess.pgn();
            }
            
            // Clear selection and valid moves
            selectedPiece = null;
            validMoves = [];
            
            // Render the updated board
            renderBoard();
            
            // If the game is in AI mode and it's AI's turn, make the AI move
            if (gameMode === "ai" && !chess.game_over() && chess.turn() === (aiColor === "black" ? 'b' : 'w')) {
              makeAIMove();
            }
          }
        } else {
          // If clicking on another one of the player's pieces, select that piece instead
          if (piece && piece.color === chess.turn()) {
            selectedPiece = { row, col, piece: getPieceNotation(piece), square };
            validMoves = getValidMovesForSquare(row, col);
          } else {
            // Otherwise, deselect
            selectedPiece = null;
            validMoves = [];
          }
          
          renderBoard();
        }
      }
      
      // Update the game status display
      function updateGameStatus() {
        const currentTurn = chess.turn() === 'w' ? "WHITE" : "BLACK";
        currentPlayerElement.textContent = currentTurn;
        
        if (chess.in_checkmate()) {
          gameStatusElement.textContent = "CHECKMATE";
          const winner = currentTurn === "WHITE" ? "BLACK" : "WHITE";
          const winnerElement = document.createElement("div");
          winnerElement.className = "winner";
          winnerElement.textContent = `${winner} WINS!`;
          gameStatusElement.appendChild(winnerElement);
          
          // Calculate score for Farcade SDK
          if ((winner === "WHITE" && gameMode === "ai" && aiColor === "black") || 
              (winner === "BLACK" && gameMode === "ai" && aiColor === "white")) {
            // Player won against AI
            gameScore = 2;
          } else if (gameMode === "ai") {
            // Player lost against AI
            gameScore = 0;
          }
          
          // Add game over overlay with Submit Score button
          showGameOverOverlay("CHECKMATE", winner);
          
        } else if (chess.in_stalemate()) {
          gameStatusElement.textContent = "DRAW";
          const drawElement = document.createElement("div");
          drawElement.className = "winner";
          drawElement.textContent = "STALEMATE";
          gameStatusElement.appendChild(drawElement);
          gameScore = 1;
          
          showGameOverOverlay("DRAW", "STALEMATE");
          
        } else if (chess.in_threefold_repetition()) {
          gameStatusElement.textContent = "DRAW";
          const drawElement = document.createElement("div");
          drawElement.className = "winner";
          drawElement.textContent = "REPETITION";
          gameStatusElement.appendChild(drawElement);
          gameScore = 1;
          
          showGameOverOverlay("DRAW", "Same position repeated 3 times");
          
        } else if (chess.insufficient_material()) {
          gameStatusElement.textContent = "DRAW";
          const drawElement = document.createElement("div");
          drawElement.className = "winner";
          drawElement.textContent = "INSUFFICIENT MATERIAL";
          gameStatusElement.appendChild(drawElement);
          gameScore = 1;
          
          showGameOverOverlay("DRAW", "Insufficient material to checkmate");
          
        } else if (chess.in_draw()) {
          gameStatusElement.textContent = "DRAW";
          const drawElement = document.createElement("div");
          drawElement.className = "winner";
          drawElement.textContent = "DRAW";
          gameStatusElement.appendChild(drawElement);
          gameScore = 1;
          
          showGameOverOverlay("DRAW", "50 moves without a capture or pawn move");
          
        } else if (chess.in_check()) {
          gameStatusElement.textContent = "CHECK";
        } else {
          gameStatusElement.textContent = gameMode === "ai" ? "PLAYING vs AI" : "PLAYING";
        }
      }
      
      // Show Game Over Overlay
      function showGameOverOverlay(title, subtext) {
        const overlay = document.createElement("div");
        overlay.className = "checkmate-overlay";
        
        const content = document.createElement("div");
        content.style.display = "flex";
        content.style.flexDirection = "column";
        content.style.alignItems = "center";
        content.style.gap = "10px";
        
        const titleElement = document.createElement("div");
        titleElement.className = "checkmate-text";
        titleElement.textContent = title;
        
        const subtextElement = document.createElement("div");
        subtextElement.className = "scoreboard-text";
        subtextElement.textContent = subtext;
        
        const buttonContainer = document.createElement("div");
        buttonContainer.style.display = "flex";
        buttonContainer.style.gap = "10px";
        
        const newGameButton = document.createElement("button");
        newGameButton.className = "modal-button";
        newGameButton.textContent = "NEW GAME";
        newGameButton.id = "new-game-checkmate";
        newGameButton.addEventListener("click", resetGame);
        
        const submitScoreButton = document.createElement("button");
        submitScoreButton.className = "modal-button";
        submitScoreButton.textContent = "SUBMIT SCORE";
        submitScoreButton.addEventListener("click", () => {
          // Disable the button immediately to prevent multiple clicks
          submitScoreButton.disabled = true;
          submitScoreButton.textContent = "SUBMITTING...";
          
          // Call Farcade SDK gameOver using the updateFarcadeScore function
          updateFarcadeScore();
          
          // Create and show a confirmation message
          const confirmationMsg = document.createElement("div");
          confirmationMsg.className = "winner";
          confirmationMsg.style.fontSize = "0.7rem";
          confirmationMsg.style.marginTop = "10px";
          confirmationMsg.textContent = "SCORE SUBMITTED!";
          content.appendChild(confirmationMsg);
          
          // Hide the button
          submitScoreButton.style.display = "none";
          
          // Trigger haptic feedback for confirmation
          triggerHapticFeedback();
        });
        
        content.appendChild(titleElement);
        content.appendChild(subtextElement);
        buttonContainer.appendChild(newGameButton);
        buttonContainer.appendChild(submitScoreButton);
        content.appendChild(buttonContainer);
        overlay.appendChild(content);
        boardElement.appendChild(overlay);
        
        triggerHapticFeedback();
      }
      
      // Calculate the score difference between captured pieces
      function calculateScoreDifference() {
        const pieceValues = {
          p: 1, // pawn
          n: 3, // knight
          b: 3, // bishop
          r: 5, // rook
          q: 9, // queen
          k: 0, // king (not factored in material evaluation)
        };
        
        let whiteScore = 0;
        let blackScore = 0;
        
        // Calculate score from captured pieces
        capturedPieces.white.forEach((piece) => {
          whiteScore += pieceValues[piece.toLowerCase()];
        });
        
        capturedPieces.black.forEach((piece) => {
          blackScore += pieceValues[piece.toLowerCase()];
        });
        
        return { whiteScore, blackScore };
      }
      
      // Update the captured pieces display
      function updateCapturedPieces() {
        // Clear current display
        whiteCapturedElement.innerHTML = "";
        blackCapturedElement.innerHTML = "";
        
        // Add each captured piece to the display
        capturedPieces.white.forEach((piece) => {
          const pieceSpan = document.createElement("span");
          pieceSpan.textContent = pieceMapping[piece];
          pieceSpan.className = "black-piece"; // These are black pieces captured by white
          whiteCapturedElement.appendChild(pieceSpan);
        });
        
        capturedPieces.black.forEach((piece) => {
          const pieceSpan = document.createElement("span");
          pieceSpan.textContent = pieceMapping[piece];
          pieceSpan.className = "white-piece"; // These are white pieces captured by black
          blackCapturedElement.appendChild(pieceSpan);
        });
        
        // Update score display
        const { whiteScore, blackScore } = calculateScoreDifference();
        
        if (whiteScore > blackScore) {
          whiteScoreElement.textContent = `+${whiteScore - blackScore}`;
          blackScoreElement.textContent = "+0";
        } else if (blackScore > whiteScore) {
          blackScoreElement.textContent = `+${blackScore - whiteScore}`;
          whiteScoreElement.textContent = "+0";
        } else {
          whiteScoreElement.textContent = "+0";
          blackScoreElement.textContent = "+0";
        }
      }
      
      // AI OPPONENT FUNCTIONS
      
      // Make AI move
      function makeAIMove() {
        // Prevent AI move if game is over or it's not AI's turn
        if (chess.game_over() || chess.turn() !== (aiColor === "black" ? 'b' : 'w')) {
          return;
        }
        
        debugLog("AI starting move evaluation");
        aiThinking = true;
        selectedPiece = null; // Ensure no piece selection interferes
        validMoves = []; // Clear any leftover valid moves display
        renderBoard(); // Update board to show AI is thinking
        
        // Use setTimeout to simulate thinking time and prevent blocking the UI
        setTimeout(() => {
          // Double-check game status hasn't changed
          if (chess.game_over() || chess.turn() !== (aiColor === "black" ? 'b' : 'w')) {
            debugLog("AI move aborted, game ended during thinking time.");
            aiThinking = false;
            renderBoard();
            return;
          }
          
          // Get all legal moves
          const moves = chess.moves({ verbose: true });
          
          if (moves.length === 0) {
            aiThinking = false;
            renderBoard();
            return;
          }
          
          // Evaluate each move with a simple heuristic
          const evaluatedMoves = moves.map(move => {
            // Create a temporary chess instance to simulate the move
            const tempChess = new Chess(chess.fen());
            tempChess.move(move);
            
            // Simple evaluation: material + position + randomness
            let score = 0;
            
            // Material score - check if the move captures a piece
            if (move.captured) {
              const pieceValues = { p: 1, n: 3, b: 3, r: 5, q: 9 };
              score += pieceValues[move.captured] || 1;
            }
            
            // Position score - bonus for controlling center
            const [toRow, toCol] = squareToCoords(move.to);
            const centerBonus = 4 - Math.abs(toRow - 3.5) - Math.abs(toCol - 3.5);
            score += centerBonus * 0.1;
            
            // Check if the move gives check
            if (tempChess.in_check()) {
              score += 0.5;
            }
            
            // Check if the move gives checkmate
            if (tempChess.in_checkmate()) {
              score += 100;
            }
            
            // Add a small random factor (0-0.2) to avoid predictable play
            score += Math.random() * 0.2;
            
            return { move, score };
          });
          
          // Sort moves by score (best first)
          evaluatedMoves.sort((a, b) => b.score - a.score);
          
          // Select from top moves with weighted probability
          const topMoves = evaluatedMoves.slice(0, Math.max(1, Math.floor(evaluatedMoves.length * 0.3)));
          
          // Weighted selection
          const weights = [];
          let totalWeight = 0;
          
          for (let i = 0; i < topMoves.length; i++) {
            const weight = Math.pow(0.7, i); // Exponential decay of probability
            weights.push(weight);
            totalWeight += weight;
          }
          
          // Small chance to pick the absolute best move
          if (Math.random() < 0.1) {
            selectedMove = topMoves[0].move;
          } else {
            // Otherwise, weighted random selection from top moves
            let random = Math.random() * totalWeight;
            for (let i = 0; i < weights.length; i++) {
              random -= weights[i];
              if (random <= 0) {
                selectedMove = topMoves[i].move;
                break;
              }
            }
          }
          
          // If somehow no move was selected, pick the best one
          if (!selectedMove) {
            selectedMove = topMoves[0].move;
          }
          
          debugLog("AI selected move:", selectedMove);
          
          // Make the selected move
          const moveResult = chess.move(selectedMove);
          
          // Update last move for highlighting
          lastMove = {
            from: squareToCoords(moveResult.from),
            to: squareToCoords(moveResult.to)
          };
          
          // Update captured pieces
          updateCapturedPiecesFromMove(moveResult);
          
          // Update PGN output
          const pgnOutput = document.getElementById("pgn-output");
          if (pgnOutput) {
            pgnOutput.textContent = "PGN: " + chess.pgn();
          }
          
          aiThinking = false;
          
          // Render the updated board
          renderBoard();
          
          // Trigger haptic feedback
          triggerHapticFeedback();
          
        }, 500); // AI "thinking" delay
      }
      
      // Reset the game to the initial state
      function resetGame() {
        chess = new Chess(); // Reset chess instance
        selectedPiece = null;
        validMoves = [];
        lastMove = { from: null, to: null };
        aiThinking = false;
        gameScore = 0;
        capturedPieces = { white: [], black: [] };
        
        // Clear PGN display
        const pgnOutput = document.getElementById("pgn-output");
        if (pgnOutput) {
          pgnOutput.textContent = "";
        }
        
        renderBoard();
        
        // If it's an AI game and AI plays as white, make the first move
        if (gameMode === "ai" && aiColor === "white") {
          setTimeout(() => {
            makeAIMove();
          }, 500);
        }
        
        // Remove any existing game over overlay
        const existingOverlay = boardElement.querySelector(".checkmate-overlay");
        if (existingOverlay) {
          boardElement.removeChild(existingOverlay);
        }
      }
      
      // Haptic feedback with Farcade SDK
      function triggerHapticFeedback() {
        if (window.FarcadeSDK && typeof window.FarcadeSDK.singlePlayer?.actions?.hapticFeedback === 'function') {
          window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
        }
      }
      
      // Update Farcade score
      function updateFarcadeScore() {
        if (window.FarcadeSDK) {
          window.FarcadeSDK.singlePlayer.actions.gameOver({
            score: gameScore,
          });
        }
      }

      // Touch event handlers
      // Add touch drag and drop functionality similar to original implementation
      let activeGhost = null;
      let isPieceBeingDragged = false;
      
      boardElement.addEventListener("touchstart", (e) => {
        if (chess.game_over() || aiThinking) {
          return;
        }
        
        const touch = e.touches[0];
        const element = document.elementFromPoint(touch.clientX, touch.clientY);
        
        if (!element || !element.classList.contains("piece")) return;
        
        const square = element.parentElement;
        const row = parseInt(square.dataset.row);
        const col = parseInt(square.dataset.col);
        const algebraicSquare = coordsToSquare(row, col);
        const piece = chess.get(algebraicSquare);
        
        if (!piece || piece.color !== chess.turn()) return;
        
        e.preventDefault();
        isPieceBeingDragged = true;
        
        // Use the same selection system as click handling
        selectedPiece = { 
          row, col, 
          piece: getPieceNotation(piece), 
          square: algebraicSquare 
        };
        
        validMoves = getValidMovesForSquare(row, col);
        
        // Create ghost piece
        activeGhost = element.cloneNode(true);
        activeGhost.classList.add("ghost-piece");
        activeGhost.style.left = `${touch.clientX}px`;
        activeGhost.style.top = `${touch.clientY}px`;
        document.body.appendChild(activeGhost);
        
        // Add dragging state to original piece
        element.classList.add("dragging");
        
        // Highlight valid moves
        validMoves.forEach(([r, c]) => {
          const targetSquare = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
          if (targetSquare) {
            const targetAlgebraicSquare = coordsToSquare(r, c);
            const targetPiece = chess.get(targetAlgebraicSquare);
            
            if (targetPiece) {
              targetSquare.classList.add("capture-highlight");
            } else {
              targetSquare.classList.add("valid-drop");
            }
          }
        });
      });
      
      document.addEventListener("touchmove", (e) => {
        if (!activeGhost || !isPieceBeingDragged) return;
        
        e.preventDefault();
        const touch = e.touches[0];
        activeGhost.style.left = `${touch.clientX}px`;
        activeGhost.style.top = `${touch.clientY}px`;
        
        // Update highlights based on current touch position
        const targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
        if (targetElement) {
          const square = targetElement.closest(".square");
          if (square) {
            const row = parseInt(square.dataset.row);
            const col = parseInt(square.dataset.col);
            
            // Remove all current highlights
            document.querySelectorAll(".square").forEach((s) => {
              s.classList.remove("valid-drop", "capture-highlight");
            });
            
            // Add appropriate highlight if it's a valid move
            const isValid = validMoves.some(([r, c]) => r === row && c === col);
            if (isValid) {
              const targetAlgebraicSquare = coordsToSquare(row, col);
              const targetPiece = chess.get(targetAlgebraicSquare);
              
              if (targetPiece) {
                square.classList.add("capture-highlight");
              } else {
                square.classList.add("valid-drop");
              }
            }
          }
        }
      });
      
      document.addEventListener("touchend", (e) => {
        if (!activeGhost || !isPieceBeingDragged || !selectedPiece) {
          return;
        }
        
        e.preventDefault();
        isPieceBeingDragged = false;
        
        // Remove ghost piece
        document.body.removeChild(activeGhost);
        activeGhost = null;
        
        // Remove dragging class from original piece
        const originalPiece = document.querySelector(".piece.dragging");
        if (originalPiece) {
          originalPiece.classList.remove("dragging");
        }
        
        // Find the square under the touch position
        const touch = e.changedTouches[0];
        const targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
        if (!targetElement) return;
        
        const square = targetElement.closest(".square");
        if (!square) {
          // If not dropped on a square, clean up
          selectedPiece = null;
          validMoves = [];
          renderBoard();
          return;
        }
        
        const toRow = parseInt(square.dataset.row);
        const toCol = parseInt(square.dataset.col);
        const toSquare = coordsToSquare(toRow, toCol);
        
        // Check if this is a valid move
        const isValid = validMoves.some(([r, c]) => r === toRow && c === toCol);
        
        if (isValid) {
          const isCapture = chess.get(toSquare) !== null;
          
          // Make the move
          const moveResult = chess.move({
            from: selectedPiece.square,
            to: toSquare,
            promotion: 'q' // Auto-promote to queen for simplicity
          });
          
          if (moveResult) {
            // Update last move for highlighting
            lastMove = {
              from: squareToCoords(moveResult.from),
              to: squareToCoords(moveResult.to)
            };
            
            // Update captured pieces
            updateCapturedPiecesFromMove(moveResult);
            
            // Update PGN output
            const pgnOutput = document.getElementById("pgn-output");
            if (pgnOutput) {
              pgnOutput.textContent = "PGN: " + chess.pgn();
            }
            
            // Clear selection and valid moves
            selectedPiece = null;
            validMoves = [];
            
            // Render the updated board
            renderBoard();
            
            // Trigger haptic feedback
            triggerHapticFeedback();
            
            // If it's an AI game and it's AI's turn, schedule the AI move
            if (gameMode === "ai" && !chess.game_over() && chess.turn() === (aiColor === "black" ? 'b' : 'w')) {
              setTimeout(() => {
                makeAIMove();
              }, 500);
            }
          }
        } else {
          // Invalid move, clean up
          selectedPiece = null;
          validMoves = [];
          renderBoard();
        }
      });
      
      // Event listeners
      
      // Modal controls
      menuButton.addEventListener("click", () => {
        menuModal.classList.add("active");
      });
      
      closeModalButton.addEventListener("click", () => {
        menuModal.classList.remove("active");
      });
      
      newGameModalButton.addEventListener("click", () => {
        resetGame();
        menuModal.classList.remove("active");
      });
      
      // Game mode buttons
      const modeHumanButton = document.getElementById("mode-human");
      const modeAIButton = document.getElementById("mode-ai");
      const aiOptionsContainer = document.getElementById("ai-options");
      const aiColorWhiteButton = document.getElementById("ai-color-white");
      const aiColorBlackButton = document.getElementById("ai-color-black");
      
      modeHumanButton.addEventListener("click", () => {
        gameMode = "human";
        modeHumanButton.classList.add("active");
        modeAIButton.classList.remove("active");
        aiOptionsContainer.style.display = "none";
      });
      
      modeAIButton.addEventListener("click", () => {
        gameMode = "ai";
        modeAIButton.classList.add("active");
        modeHumanButton.classList.remove("active");
        aiOptionsContainer.style.display = "block";
      });
      
      aiColorWhiteButton.addEventListener("click", () => {
        aiColor = "white";
        aiColorWhiteButton.classList.add("active");
        aiColorBlackButton.classList.remove("active");
      });
      
      aiColorBlackButton.addEventListener("click", () => {
        aiColor = "black";
        aiColorWhiteButton.classList.remove("active");
        aiColorBlackButton.classList.add("active");
      });
      
      // Initialize the game
      renderBoard();
      
      // Set initial UI state for AI options
      aiOptionsContainer.style.display = gameMode === "ai" ? "block" : "none";
      
      // Set initial button states to match default game mode
      if (gameMode === "ai") {
        modeAIButton.classList.add("active");
        modeHumanButton.classList.remove("active");
      } else {
        modeHumanButton.classList.add("active");
        modeAIButton.classList.remove("active");
      }
      
      // Set AI color button states
      if (aiColor === "black") {
        aiColorWhiteButton.classList.add("active");
        aiColorBlackButton.classList.remove("active");
      } else {
        aiColorBlackButton.classList.add("active");
        aiColorWhiteButton.classList.remove("active");
      }
      
      // Re-run the makeAIMove function in case AI should move first
      if (gameMode === "ai" && aiColor === "white") {
        setTimeout(() => {
          makeAIMove();
        }, 500);
      }

      // Listen for Farcade SDK events
      if (window.FarcadeSDK) {
        // Handle play_again event
        window.FarcadeSDK.on("play_again", () => {
          // Reset the game state
          resetGame();
        });
        
        // Handle toggle_mute event
        window.FarcadeSDK.on("toggle_mute", (data) => {
          // Set muted state based on data.isMuted
          isMuted = data.isMuted;
          // No actual sounds in the game, but track the mute state
          console.log("Game " + (isMuted ? "muted" : "unmuted"));
        });
      }

      // Farcade SDK Integration
      window.addEventListener("DOMContentLoaded", () => {
        if (window.FarcadeSDK) {
          // Signal that the game is ready to play
          window.FarcadeSDK.singlePlayer.actions.ready();
        }
      });
    </script>
  </body>
</html>
